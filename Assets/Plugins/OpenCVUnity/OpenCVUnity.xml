<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OpenCVUnity</name>
    </assembly>
    <members>
        <member name="T:OpenCVUnity.Calib3d">
            <summary>
            Calibration class for camera and 3D purposes
            </summary>
        </member>
        <member name="M:OpenCVUnity.Calib3d.RQDecomp3x3(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Computes an RQ decomposition of 3x3 matrices.</summary>
            
             <p>The function computes a RQ decomposition using the given rotations. This
             function is used in "decomposeProjectionMatrix" to decompose the left 3x3
             submatrix of a projection matrix into a camera and a rotation matrix.</p>
            
             <p>It optionally returns three rotation matrices, one for each axis, and the
             three Euler angles in degrees (as the return value) that could be used in
             OpenGL. Note, there is always more than one sequence of rotations about the
             three principle axes that results in the same orientation of an object, eg.
             see [Slabaugh]. Returned tree rotation matrices and corresponding three Euler
             angules are only one of the possible solutions.</p>
            
             <param>src 3x3 input matrix.</param>
             <param>mtxR Output 3x3 upper-triangular matrix.</param>
             <param>mtxQ Output 3x3 orthogonal matrix.</param>
             <param>Qx Optional output 3x3 rotation matrix around x-axis.</param>
             <param>Qy Optional output 3x3 rotation matrix around y-axis.</param>
             <param>Qz Optional output 3x3 rotation matrix around z-axis.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3">org.opencv.calib3d.Calib3d.RQDecomp3x3</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.RQDecomp3x3(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Computes an RQ decomposition of 3x3 matrices.</summary>
            
             <p>The function computes a RQ decomposition using the given rotations. This
             function is used in "decomposeProjectionMatrix" to decompose the left 3x3
             submatrix of a projection matrix into a camera and a rotation matrix.</p>
            
             <p>It optionally returns three rotation matrices, one for each axis, and the
             three Euler angles in degrees (as the return value) that could be used in
             OpenGL. Note, there is always more than one sequence of rotations about the
             three principle axes that results in the same orientation of an object, eg.
             see [Slabaugh]. Returned tree rotation matrices and corresponding three Euler
             angules are only one of the possible solutions.</p>
            
             <param>src 3x3 input matrix.</param>
             <param>mtxR Output 3x3 upper-triangular matrix.</param>
             <param>mtxQ Output 3x3 orthogonal matrix.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3">org.opencv.calib3d.Calib3d.RQDecomp3x3</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.Rodrigues(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.Rodrigues(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.calibrateCamera(System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},System.Int32,OpenCVUnity.TermCriteria)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.calibrateCamera(System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.calibrateCamera(System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat})" -->
        <member name="M:OpenCVUnity.Calib3d.calibrationMatrixValues(OpenCVUnity.Mat,OpenCVUnity.Size,System.Double,System.Double,System.Double[],System.Double[],System.Double[],OpenCVUnity.Point,System.Double[])">
             <summary>Computes useful camera characteristics from the camera matrix.</summary>
            
             <p>The function computes various useful camera characteristics from the
             previously estimated camera matrix.</p>
            
             <p>Note:</p>
            
             <p>Do keep in mind that the unity measure 'mm' stands for whatever unit of
             measure one chooses for the chessboard pitch (it can thus be any value).</p>
            
             <param>cameraMatrix Input camera matrix that can be estimated by
             "calibrateCamera" or "stereoCalibrate".</param>
             <param>imageSize Input image size in pixels.</param>
             <param>apertureWidth Physical width in mm of the sensor.</param>
             <param>apertureHeight Physical height in mm of the sensor.</param>
             <param>fovx Output field of view in degrees along the horizontal sensor axis.</param>
             <param>fovy Output field of view in degrees along the vertical sensor axis.</param>
             <param>focalLength Focal length of the lens in mm.</param>
             <param>principalPoint Principal point in mm.</param>
             <param>aspectRatio <em>f_y/f_x</em></param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibrationmatrixvalues">org.opencv.calib3d.Calib3d.calibrationMatrixValues</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.composeRT(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Combines two rotation-and-shift transformations.</summary>
            
             <p>The functions compute:</p>
            
             <p><em>rvec3 = rodrigues ^(-1)(rodrigues(rvec2)/// rodrigues(rvec1))
             tvec3 = rodrigues(rvec2)/// tvec1 + tvec2,</em></p>
            
             <p>where <em>rodrigues</em> denotes a rotation vector to a rotation matrix
             transformation, and <em>rodrigues^(-1)</em> denotes the inverse
             transformation. See "Rodrigues" for details.</p>
            
             <p>Also, the functions can compute the derivatives of the output vectors with
             regards to the input vectors (see "matMulDeriv").
             The functions are used inside "stereoCalibrate" but can also be used in your
             own code where Levenberg-Marquardt or another gradient-based solver is used
             to optimize a function that contains a matrix multiplication.</p>
            
             <param>rvec1 First rotation vector.</param>
             <param>tvec1 First translation vector.</param>
             <param>rvec2 Second rotation vector.</param>
             <param>tvec2 Second translation vector.</param>
             <param>rvec3 Output rotation vector of the superposition.</param>
             <param>tvec3 Output translation vector of the superposition.</param>
             <param>dr3dr1 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
             <param>dr3dt1 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
             <param>dr3dr2 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
             <param>dr3dt2 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
             <param>dt3dr1 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
             <param>dt3dt1 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
             <param>dt3dr2 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
             <param>dt3dt2 Optional output derivatives of <code>rvec3</code> or
             <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
             <code>tvec1</code> and <code>tvec2</code>, respectively.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#composert">org.opencv.calib3d.Calib3d.composeRT</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.composeRT(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Combines two rotation-and-shift transformations.</summary>
            
             <p>The functions compute:</p>
            
             <p><em>rvec3 = rodrigues ^(-1)(rodrigues(rvec2)/// rodrigues(rvec1))
             tvec3 = rodrigues(rvec2)/// tvec1 + tvec2,</em></p>
            
             <p>where <em>rodrigues</em> denotes a rotation vector to a rotation matrix
             transformation, and <em>rodrigues^(-1)</em> denotes the inverse
             transformation. See "Rodrigues" for details.</p>
            
             <p>Also, the functions can compute the derivatives of the output vectors with
             regards to the input vectors (see "matMulDeriv").
             The functions are used inside "stereoCalibrate" but can also be used in your
             own code where Levenberg-Marquardt or another gradient-based solver is used
             to optimize a function that contains a matrix multiplication.</p>
            
             <param>rvec1 First rotation vector.</param>
             <param>tvec1 First translation vector.</param>
             <param>rvec2 Second rotation vector.</param>
             <param>tvec2 Second translation vector.</param>
             <param>rvec3 Output rotation vector of the superposition.</param>
             <param>tvec3 Output translation vector of the superposition.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#composert">org.opencv.calib3d.Calib3d.composeRT</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.computeCorrespondEpilines(OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Calib3d.convertPointsFromHomogeneous(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Converts points from homogeneous to Euclidean space.</summary>
            
             <p>The function converts points homogeneous to Euclidean space using perspective
             projection. That is, each point <code>(x1, x2,... x(n-1), xn)</code> is
             converted to <code>(x1/xn, x2/xn,..., x(n-1)/xn)</code>. When
             <code>xn=0</code>, the output point coordinates will be <code>(0,0,0,...)</code>.</p>
            
             <param>src Input vector of <code>N</code>-dimensional points.</param>
             <param>dst Output vector of <code>N-1</code>-dimensional points.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#convertpointsfromhomogeneous">org.opencv.calib3d.Calib3d.convertPointsFromHomogeneous</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.convertPointsToHomogeneous(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Converts points from Euclidean to homogeneous space.</summary>
            
             <p>The function converts points from Euclidean to homogeneous space by appending
             1's to the tuple of point coordinates. That is, each point <code>(x1, x2,...,
             xn)</code> is converted to <code>(x1, x2,..., xn, 1)</code>.</p>
            
             <param>src Input vector of <code>N</code>-dimensional points.</param>
             <param>dst Output vector of <code>N+1</code>-dimensional points.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#convertpointstohomogeneous">org.opencv.calib3d.Calib3d.convertPointsToHomogeneous</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.correctMatches(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Calib3d.decomposeProjectionMatrix(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Decomposes a projection matrix into a rotation matrix and a camera matrix.</summary>
            
             <p>The function computes a decomposition of a projection matrix into a
             calibration and a rotation matrix and the position of a camera.</p>
            
             <p>It optionally returns three rotation matrices, one for each axis, and three
             Euler angles that could be used in OpenGL. Note, there is always more than
             one sequence of rotations about the three principle axes that results in the
             same orientation of an object, eg. see [Slabaugh]. Returned tree rotation
             matrices and corresponding three Euler angules are only one of the possible
             solutions.</p>
            
             <p>The function is based on "RQDecomp3x3".</p>
            
             <param>projMatrix 3x4 input projection matrix P.</param>
             <param>cameraMatrix Output 3x3 camera matrix K.</param>
             <param>rotMatrix Output 3x3 external rotation matrix R.</param>
             <param>transVect Output 4x1 translation vector T.</param>
             <param>rotMatrixX a rotMatrixX</param>
             <param>rotMatrixY a rotMatrixY</param>
             <param>rotMatrixZ a rotMatrixZ</param>
             <param>eulerAngles Optional three-element vector containing three Euler
             angles of rotation in degrees.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix">org.opencv.calib3d.Calib3d.decomposeProjectionMatrix</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.decomposeProjectionMatrix(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Decomposes a projection matrix into a rotation matrix and a camera matrix.</summary>
            
             <p>The function computes a decomposition of a projection matrix into a
             calibration and a rotation matrix and the position of a camera.</p>
            
             <p>It optionally returns three rotation matrices, one for each axis, and three
             Euler angles that could be used in OpenGL. Note, there is always more than
             one sequence of rotations about the three principle axes that results in the
             same orientation of an object, eg. see [Slabaugh]. Returned tree rotation
             matrices and corresponding three Euler angules are only one of the possible
             solutions.</p>
            
             <p>The function is based on "RQDecomp3x3".</p>
            
             <param>projMatrix 3x4 input projection matrix P.</param>
             <param>cameraMatrix Output 3x3 camera matrix K.</param>
             <param>rotMatrix Output 3x3 external rotation matrix R.</param>
             <param>transVect Output 4x1 translation vector T.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix">org.opencv.calib3d.Calib3d.decomposeProjectionMatrix</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.drawChessboardCorners(OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.MatOfPoint2f,System.Boolean)">
             <summary>Renders the detected chessboard corners.</summary>
            
             <p>The function draws individual chessboard corners detected either as red
             circles if the board was not found, or as colored corners connected with
             lines if the board was found.</p>
            
             <param>image Destination image. It must be an 8-bit color image.</param>
             <param>patternSize Number of inner corners per a chessboard row and column
             <code>(patternSize = cv.Size(points_per_row,points_per_column))</code>.</param>
             <param>corners Array of detected corners, the output of <code>findChessboardCorners</code>.</param>
             <param>patternWasFound Parameter indicating whether the complete board was
             found or not. The return value of "findChessboardCorners" should be passed
             here.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#drawchessboardcorners">org.opencv.calib3d.Calib3d.drawChessboardCorners</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.estimateAffine3D(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double)">
             <summary>Computes an optimal affine transformation between two 3D point sets.</summary>
            
             <p>The function estimates an optimal 3D affine transformation between two 3D
             point sets using the RANSAC algorithm.</p>
            
             <param>src First input 3D point set.</param>
             <param>dst Second input 3D point set.</param>
             <param>out Output 3D affine transformation matrix <em>3 x 4</em>.</param>
             <param>inliers Output vector indicating which points are inliers.</param>
             <param>ransacThreshold Maximum reprojection error in the RANSAC algorithm to
             consider a point as an inlier.</param>
             <param>confidence Confidence level, between 0 and 1, for the estimated
             transformation. Anything between 0.95 and 0.99 is usually good enough. Values
             too close to 1 can slow down the estimation significantly. Values lower than
             0.8-0.9 can result in an incorrectly estimated transformation.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#estimateaffine3d">org.opencv.calib3d.Calib3d.estimateAffine3D</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.estimateAffine3D(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Computes an optimal affine transformation between two 3D point sets.</summary>
            
             <p>The function estimates an optimal 3D affine transformation between two 3D
             point sets using the RANSAC algorithm.</p>
            
             <param>src First input 3D point set.</param>
             <param>dst Second input 3D point set.</param>
             <param>out Output 3D affine transformation matrix <em>3 x 4</em>.</param>
             <param>inliers Output vector indicating which points are inliers.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#estimateaffine3d">org.opencv.calib3d.Calib3d.estimateAffine3D</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.filterSpeckles(OpenCVUnity.Mat,System.Double,System.Int32,System.Double,OpenCVUnity.Mat)">
             <summary>Filters off small noise blobs (speckles) in the disparity map</summary>
            
             <param>img The input 16-bit signed disparity image</param>
             <param>newVal The disparity value used to paint-off the speckles</param>
             <param>maxSpeckleSize The maximum speckle size to consider it a speckle.
             Larger blobs are not affected by the algorithm</param>
             <param>maxDiff Maximum difference between neighbor disparity pixels to put
             them into the same blob. Note that since StereoBM, StereoSGBM and may be
             other algorithms return a fixed-point disparity map, where disparity values
             are multiplied by 16, this scale factor should be taken into account when
             specifying this parameter value.</param>
             <param>buf The optional temporary buffer to avoid memory allocation within
             the function.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#filterspeckles">org.opencv.calib3d.Calib3d.filterSpeckles</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.filterSpeckles(OpenCVUnity.Mat,System.Double,System.Int32,System.Double)">
             <summary>Filters off small noise blobs (speckles) in the disparity map</summary>
            
             <param>img The input 16-bit signed disparity image</param>
             <param>newVal The disparity value used to paint-off the speckles</param>
             <param>maxSpeckleSize The maximum speckle size to consider it a speckle.
             Larger blobs are not affected by the algorithm</param>
             <param>maxDiff Maximum difference between neighbor disparity pixels to put
             them into the same blob. Note that since StereoBM, StereoSGBM and may be
             other algorithms return a fixed-point disparity map, where disparity values
             are multiplied by 16, this scale factor should be taken into account when
             specifying this parameter value.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#filterspeckles">org.opencv.calib3d.Calib3d.filterSpeckles</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findChessboardCorners(OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.MatOfPoint2f,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findChessboardCorners(OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.MatOfPoint2f)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findFundamentalMat(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,System.Int32,System.Double,System.Double,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findFundamentalMat(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findFundamentalMat(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findHomography(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,System.Int32,System.Double,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findHomography(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.findHomography(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f)" -->
        <member name="M:OpenCVUnity.Calib3d.getOptimalNewCameraMatrix(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Double,OpenCVUnity.Size,OpenCVUnity.Rect,System.Boolean)">
             <summary>Returns the new camera matrix based on the free scaling parameter.</summary>
            
             <p>The function computes and returns the optimal new camera matrix based on the
             free scaling parameter. By varying this parameter, you may retrieve only
             sensible pixels <code>alpha=0</code>, keep all the original image pixels if
             there is valuable information in the corners <code>alpha=1</code>, or get
             something in between. When <code>alpha>0</code>, the undistortion result is
             likely to have some black pixels corresponding to "virtual" pixels outside of
             the captured distorted image. The original camera matrix, distortion
             coefficients, the computed new camera matrix, and <code>newImageSize</code>
             should be passed to "initUndistortRectifyMap" to produce the maps for
             "remap".</p>
            
             <param>cameraMatrix Input camera matrix.</param>
             <param>distCoeffs Input vector of distortion coefficients <em>(k_1, k_2, p_1,
             p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
             NULL/empty, the zero distortion coefficients are assumed.</param>
             <param>imageSize Original image size.</param>
             <param>alpha Free scaling parameter between 0 (when all the pixels in the
             undistorted image are valid) and 1 (when all the source image pixels are
             retained in the undistorted image). See "stereoRectify" for details.</param>
             <param>newImgSize a newImgSize</param>
             <param>validPixROI Optional output rectangle that outlines all-good-pixels
             region in the undistorted image. See <code>roi1, roi2</code> description in
             "stereoRectify".</param>
             <param>centerPrincipalPoint Optional flag that indicates whether in the new
             camera matrix the principal point should be at the image center or not. By
             default, the principal point is chosen to best fit a subset of the source
             image (determined by <code>alpha</code>) to the corrected image.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix">org.opencv.calib3d.Calib3d.getOptimalNewCameraMatrix</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.getOptimalNewCameraMatrix(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Double)">
             <summary>Returns the new camera matrix based on the free scaling parameter.</summary>
            
             <p>The function computes and returns the optimal new camera matrix based on the
             free scaling parameter. By varying this parameter, you may retrieve only
             sensible pixels <code>alpha=0</code>, keep all the original image pixels if
             there is valuable information in the corners <code>alpha=1</code>, or get
             something in between. When <code>alpha>0</code>, the undistortion result is
             likely to have some black pixels corresponding to "virtual" pixels outside of
             the captured distorted image. The original camera matrix, distortion
             coefficients, the computed new camera matrix, and <code>newImageSize</code>
             should be passed to "initUndistortRectifyMap" to produce the maps for
             "remap".</p>
            
             <param>cameraMatrix Input camera matrix.</param>
             <param>distCoeffs Input vector of distortion coefficients <em>(k_1, k_2, p_1,
             p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
             NULL/empty, the zero distortion coefficients are assumed.</param>
             <param>imageSize Original image size.</param>
             <param>alpha Free scaling parameter between 0 (when all the pixels in the
             undistorted image are valid) and 1 (when all the source image pixels are
             retained in the undistorted image). See "stereoRectify" for details.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix">org.opencv.calib3d.Calib3d.getOptimalNewCameraMatrix</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.initCameraMatrix2D(System.Collections.Generic.List{OpenCVUnity.MatOfPoint3f},System.Collections.Generic.List{OpenCVUnity.MatOfPoint2f},OpenCVUnity.Size,System.Double)">
             <summary>Finds an initial camera matrix from 3D-2D point correspondences.</summary>
            
             <p>The function estimates and returns an initial camera matrix for the camera
             calibration process.
             Currently, the function only supports planar calibration patterns, which are
             patterns where each object point has z-coordinate =0.</p>
            
             <param>objectPoints Vector of vectors of the calibration pattern points in
             the calibration pattern coordinate space. In the old interface all the
             per-view vectors are concatenated. See "calibrateCamera" for details.</param>
             <param>imagePoints Vector of vectors of the projections of the calibration
             pattern points. In the old interface all the per-view vectors are
             concatenated.</param>
             <param>imageSize Image size in pixels used to initialize the principal point.</param>
             <param>aspectRatio If it is zero or negative, both <em>f_x</em> and
             <em>f_y</em> are estimated independently. Otherwise, <em>f_x = f_y///
             aspectRatio</em>.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#initcameramatrix2d">org.opencv.calib3d.Calib3d.initCameraMatrix2D</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.initCameraMatrix2D(System.Collections.Generic.List{OpenCVUnity.MatOfPoint3f},System.Collections.Generic.List{OpenCVUnity.MatOfPoint2f},OpenCVUnity.Size)">
             <summary>Finds an initial camera matrix from 3D-2D point correspondences.</summary>
            
             <p>The function estimates and returns an initial camera matrix for the camera
             calibration process.
             Currently, the function only supports planar calibration patterns, which are
             patterns where each object point has z-coordinate =0.</p>
            
             <param>objectPoints Vector of vectors of the calibration pattern points in
             the calibration pattern coordinate space. In the old interface all the
             per-view vectors are concatenated. See "calibrateCamera" for details.</param>
             <param>imagePoints Vector of vectors of the projections of the calibration
             pattern points. In the old interface all the per-view vectors are
             concatenated.</param>
             <param>imageSize Image size in pixels used to initialize the principal point.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#initcameramatrix2d">org.opencv.calib3d.Calib3d.initCameraMatrix2D</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.matMulDeriv(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Computes partial derivatives of the matrix product for each multiplied
             matrix.</summary>
            
             <p>The function computes partial derivatives of the elements of the matrix
             product <em>A*B</em> with regard to the elements of each of the two input
             matrices. The function is used to compute the Jacobian matrices in
             "stereoCalibrate" but can also be used in any other similar optimization
             function.</p>
            
             <param>A First multiplied matrix.</param>
             <param>B Second multiplied matrix.</param>
             <param>dABdA First output derivative matrix <code>d(A*B)/dA</code> of size
             <em>A.rows*B.cols x (A.rows*A.cols)</em>.</param>
             <param>dABdB Second output derivative matrix <code>d(A*B)/dB</code> of size
             <em>A.rows*B.cols x (B.rows*B.cols)</em>.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#matmulderiv">org.opencv.calib3d.Calib3d.matMulDeriv</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.projectPoints(OpenCVUnity.MatOfPoint3f,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfDouble,OpenCVUnity.MatOfPoint2f,OpenCVUnity.Mat,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.projectPoints(OpenCVUnity.MatOfPoint3f,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfDouble,OpenCVUnity.MatOfPoint2f)" -->
        <member name="M:OpenCVUnity.Calib3d.reprojectImageTo3D(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean,System.Int32)">
             <summary>Reprojects a disparity image to 3D space.</summary>
            
             <p>The function transforms a single-channel disparity map to a 3-channel image
             representing a 3D surface. That is, for each pixel <code>(x,y)</code> andthe
             corresponding disparity <code>d=disparity(x,y)</code>, it computes:</p>
            
             <p><em>[X Y Z W]^T = Q///[x y disparity(x,y) 1]^T
             _3dImage(x,y) = (X/W, Y/W, Z/W) </em></p>
            
             <p>The matrix <code>Q</code> can be an arbitrary <em>4 x 4</em> matrix (for
             example, the one computed by "stereoRectify"). To reproject a sparse set of
             points {(x,y,d),...} to 3D space, use "perspectiveTransform".</p>
            
             <param>disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit
             signed or 32-bit floating-point disparity image.</param>
             <param>_3dImage Output 3-channel floating-point image of the same size as
             <code>disparity</code>. Each element of <code>_3dImage(x,y)</code> contains
             3D coordinates of the point <code>(x,y)</code> computed from the disparity
             map.</param>
             <param>Q <em>4 x 4</em> perspective transformation matrix that can be
             obtained with "stereoRectify".</param>
             <param>handleMissingValues Indicates, whether the function should handle
             missing values (i.e. points where the disparity was not computed). If
             <code>handleMissingValues=true</code>, then pixels with the minimal disparity
             that corresponds to the outliers (see :ocv:funcx:"StereoBM.operator()") are
             transformed to 3D points with a very large Z value (currently set to 10000).</param>
             <param>ddepth The optional output array depth. If it is <code>-1</code>, the
             output image will have <code>CV_32F</code> depth. <code>ddepth</code> can
             also be set to <code>CV_16S</code>, <code>CV_32S</code> or <code>CV_32F</code>.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d">org.opencv.calib3d.Calib3d.reprojectImageTo3D</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.reprojectImageTo3D(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean)">
             <summary>Reprojects a disparity image to 3D space.</summary>
            
             <p>The function transforms a single-channel disparity map to a 3-channel image
             representing a 3D surface. That is, for each pixel <code>(x,y)</code> andthe
             corresponding disparity <code>d=disparity(x,y)</code>, it computes:</p>
            
             <p><em>[X Y Z W]^T = Q///[x y disparity(x,y) 1]^T
             _3dImage(x,y) = (X/W, Y/W, Z/W) </em></p>
            
             <p>The matrix <code>Q</code> can be an arbitrary <em>4 x 4</em> matrix (for
             example, the one computed by "stereoRectify"). To reproject a sparse set of
             points {(x,y,d),...} to 3D space, use "perspectiveTransform".</p>
            
             <param>disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit
             signed or 32-bit floating-point disparity image.</param>
             <param>_3dImage Output 3-channel floating-point image of the same size as
             <code>disparity</code>. Each element of <code>_3dImage(x,y)</code> contains
             3D coordinates of the point <code>(x,y)</code> computed from the disparity
             map.</param>
             <param>Q <em>4 x 4</em> perspective transformation matrix that can be
             obtained with "stereoRectify".</param>
             <param>handleMissingValues Indicates, whether the function should handle
             missing values (i.e. points where the disparity was not computed). If
             <code>handleMissingValues=true</code>, then pixels with the minimal disparity
             that corresponds to the outliers (see :ocv:funcx:"StereoBM.operator()") are
             transformed to 3D points with a very large Z value (currently set to 10000).</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d">org.opencv.calib3d.Calib3d.reprojectImageTo3D</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.reprojectImageTo3D(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Reprojects a disparity image to 3D space.</summary>
            
             <p>The function transforms a single-channel disparity map to a 3-channel image
             representing a 3D surface. That is, for each pixel <code>(x,y)</code> andthe
             corresponding disparity <code>d=disparity(x,y)</code>, it computes:</p>
            
             <p><em>[X Y Z W]^T = Q///[x y disparity(x,y) 1]^T
             _3dImage(x,y) = (X/W, Y/W, Z/W) </em></p>
            
             <p>The matrix <code>Q</code> can be an arbitrary <em>4 x 4</em> matrix (for
             example, the one computed by "stereoRectify"). To reproject a sparse set of
             points {(x,y,d),...} to 3D space, use "perspectiveTransform".</p>
            
             <param>disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit
             signed or 32-bit floating-point disparity image.</param>
             <param>_3dImage Output 3-channel floating-point image of the same size as
             <code>disparity</code>. Each element of <code>_3dImage(x,y)</code> contains
             3D coordinates of the point <code>(x,y)</code> computed from the disparity
             map.</param>
             <param>Q <em>4 x 4</em> perspective transformation matrix that can be
             obtained with "stereoRectify".</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d">org.opencv.calib3d.Calib3d.reprojectImageTo3D</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.solvePnP(OpenCVUnity.MatOfPoint3f,OpenCVUnity.MatOfPoint2f,OpenCVUnity.Mat,OpenCVUnity.MatOfDouble,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.solvePnP(OpenCVUnity.MatOfPoint3f,OpenCVUnity.MatOfPoint2f,OpenCVUnity.Mat,OpenCVUnity.MatOfDouble,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.stereoCalibrate(System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.TermCriteria,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.stereoCalibrate(System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.stereoRectify(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Double,OpenCVUnity.Size,OpenCVUnity.Rect,OpenCVUnity.Rect)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.stereoRectify(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Calib3d.stereoRectifyUncalibrated(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double)" -->
        <member name="M:OpenCVUnity.Calib3d.stereoRectifyUncalibrated(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Computes a rectification transform for an uncalibrated stereo camera.</summary>
            
             <p>The function computes the rectification transformations without knowing
             intrinsic parameters of the cameras and their relative position in the space,
             which explains the suffix "uncalibrated". Another related difference from
             "stereoRectify" is that the function outputs not the rectification
             transformations in the object (3D) space, but the planar perspective
             transformations encoded by the homography matrices <code>H1</code> and
             <code>H2</code>. The function implements the algorithm [Hartley99].</p>
            
             <p>Note:</p>
            
             <p>While the algorithm does not need to know the intrinsic parameters of the
             cameras, it heavily depends on the epipolar geometry. Therefore, if the
             camera lenses have a significant distortion, it would be better to correct it
             before computing the fundamental matrix and calling this function. For
             example, distortion coefficients can be estimated for each head of stereo
             camera separately by using "calibrateCamera". Then, the images can be
             corrected using "undistort", or just the point coordinates can be corrected
             with "undistortPoints".</p>
            
             <param>points1 Array of feature points in the first image.</param>
             <param>points2 The corresponding points in the second image. The same formats
             as in "findFundamentalMat" are supported.</param>
             <param>F Input fundamental matrix. It can be computed from the same set of
             point pairs using "findFundamentalMat".</param>
             <param>imgSize Size of the image.</param>
             <param>H1 Output rectification homography matrix for the first image.</param>
             <param>H2 Output rectification homography matrix for the second image.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated">org.opencv.calib3d.Calib3d.stereoRectifyUncalibrated</a>
        </member>
        <member name="M:OpenCVUnity.Calib3d.triangulatePoints(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Reconstructs points by triangulation.</summary>
            
             <p>The function reconstructs 3-dimensional points (in homogeneous coordinates)
             by using their observations with a stereo camera. Projections matrices can be
             obtained from "stereoRectify".</p>
            
             <param>projMatr1 3x4 projection matrix of the first camera.</param>
             <param>projMatr2 3x4 projection matrix of the second camera.</param>
             <param>projPoints1 2xN array of feature points in the first image. In case of
             c++ version it can be also a vector of feature points or two-channel matrix
             of size 1xN or Nx1.</param>
             <param>projPoints2 2xN array of corresponding points in the second image. In
             case of c++ version it can be also a vector of feature points or two-channel
             matrix of size 1xN or Nx1.</param>
             <param>points4D 4xN array of reconstructed points in homogeneous coordinates.</param>
            
             <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#triangulatepoints">org.opencv.calib3d.Calib3d.triangulatePoints</a>
             org.opencv.calib3d.Calib3d#reprojectImageTo3D
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.StereoBM" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.StereoSGBM" -->
        <member name="T:OpenCVUnity.Converters">
            <summary>
            Inner converters for OpenCVUnity. Should be use only inside OpenCVUnity namespace
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.Algorithm" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.LUT(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.LUT(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.Mahalanobis(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the Mahalanobis distance between two vectors.</summary>
            
             <p>The function <code>Mahalanobis</code> calculates and returns the weighted
             distance between two vectors:</p>
            
             <p><em>d(vec1, vec2)= sqrt(sum_(i,j)(icovar(i,j)*(vec1(I)-vec2(I))*(vec1(j)-vec2(j))))</em></p>
            
             <p>The covariance matrix may be calculated using the "calcCovarMatrix" function
             and then inverted using the "invert" function (preferably using the
             <code>DECOMP_SVD</code> method, as the most accurate).</p>
            
             <param>v1 a v1</param>
             <param>v2 a v2</param>
             <param>icovar inverse covariance matrix.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mahalanobis">org.opencv.core.Core.Mahalanobis</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.absdiff(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.absdiff(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.add(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.add(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.add(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.add(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.add(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.add(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.addWeighted(OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat,System.Double,System.Double,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.addWeighted(OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat,System.Double,System.Double,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.bitwise_and(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.bitwise_and(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.bitwise_not(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Inverts every bit of an array.</summary>
            
             <p>The function calculates per-element bit-wise inversion of the input array:</p>
            
             <p><em>dst(I) = !src(I)</em></p>
            
             <p>In case of a floating-point input array, its machine-specific bit
             representation (usually IEEE754-compliant) is used for the operation. In case
             of multi-channel arrays, each channel is processed independently.</p>
            
             <param>src input array.</param>
             <param>dst output array that has the same size and type as the input array.</param>
             <param>mask optional operation mask, 8-bit single channel array, that
             specifies elements of the output array to be changed.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-not">org.opencv.core.Core.bitwise_not</a>
        </member>
        <member name="M:OpenCVUnity.Core.bitwise_not(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Inverts every bit of an array.</summary>
            
             <p>The function calculates per-element bit-wise inversion of the input array:</p>
            
             <p><em>dst(I) = !src(I)</em></p>
            
             <p>In case of a floating-point input array, its machine-specific bit
             representation (usually IEEE754-compliant) is used for the operation. In case
             of multi-channel arrays, each channel is processed independently.</p>
            
             <param>src input array.</param>
             <param>dst output array that has the same size and type as the input array.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-not">org.opencv.core.Core.bitwise_not</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.bitwise_or(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.bitwise_or(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.bitwise_xor(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.bitwise_xor(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.calcCovarMatrix(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.calcCovarMatrix(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <member name="M:OpenCVUnity.Core.cartToPolar(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean)">
             <summary>Calculates the magnitude and angle of 2D vectors.</summary>
            
             <p>The function <code>cartToPolar</code> calculates either the magnitude, angle,
             or both for every 2D vector (x(I),y(I)):</p>
            
             <p><em>magnitude(I)= sqrt(x(I)^2+y(I)^2),
             angle(I)= atan2(y(I), x(I))[///180 / pi ] </em></p>
            
             <p>The angles are calculated with accuracy about 0.3 degrees. For the point
             (0,0), the angle is set to 0.</p>
            
             <param>x array of x-coordinates; this must be a single-precision or
             double-precision floating-point array.</param>
             <param>y array of y-coordinates, that must have the same size and same type
             as <code>x</code>.</param>
             <param>magnitude output array of magnitudes of the same size and type as
             <code>x</code>.</param>
             <param>angle output array of angles that has the same size and type as
             <code>x</code>; the angles are measured in radians (from 0 to 2*Pi) or in
             degrees (0 to 360 degrees).</param>
             <param>angleInDegrees a flag, indicating whether the angles are measured in
             radians (which is by default), or in degrees.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#carttopolar">org.opencv.core.Core.cartToPolar</a>
             org.opencv.imgproc.Imgproc#Scharr
             org.opencv.imgproc.Imgproc#Sobel
        </member>
        <member name="M:OpenCVUnity.Core.cartToPolar(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the magnitude and angle of 2D vectors.</summary>
            
             <p>The function <code>cartToPolar</code> calculates either the magnitude, angle,
             or both for every 2D vector (x(I),y(I)):</p>
            
             <p><em>magnitude(I)= sqrt(x(I)^2+y(I)^2),
             angle(I)= atan2(y(I), x(I))[///180 / pi ] </em></p>
            
             <p>The angles are calculated with accuracy about 0.3 degrees. For the point
             (0,0), the angle is set to 0.</p>
            
             <param>x array of x-coordinates; this must be a single-precision or
             double-precision floating-point array.</param>
             <param>y array of y-coordinates, that must have the same size and same type
             as <code>x</code>.</param>
             <param>magnitude output array of magnitudes of the same size and type as
             <code>x</code>.</param>
             <param>angle output array of angles that has the same size and type as
             <code>x</code>; the angles are measured in radians (from 0 to 2*Pi) or in
             degrees (0 to 360 degrees).</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#carttopolar">org.opencv.core.Core.cartToPolar</a>
             org.opencv.imgproc.Imgproc#Scharr
             org.opencv.imgproc.Imgproc#Sobel
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.checkRange(OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.clipLine(OpenCVUnity.Rect,OpenCVUnity.Point,OpenCVUnity.Point)">
             <summary>Clips the line against the image rectangle.</summary>
            
             <p>The functions <code>clipLine</code> calculate a part of the line segment that
             is entirely within the specified rectangle.
             They return <code>false</code> if the line segment is completely outside the
             rectangle. Otherwise, they return <code>true</code>.</p>
            
             <param>imgRect Image rectangle.</param>
             <param>pt1 First line point.</param>
             <param>pt2 Second line point.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#clipline">org.opencv.core.Core.clipLine</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.compare(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.compare(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.completeSymm(OpenCVUnity.Mat,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.completeSymm(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.convertScaleAbs(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.convertScaleAbs(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.countNonZero(OpenCVUnity.Mat)">
             <summary>Counts non-zero array elements.</summary>
            
             <p>The function returns the number of non-zero elements in <code>src</code> :</p>
            
             <p><em>sum(by: I: src(I) != 0) 1</em></p>
            
             <param>src single-channel array.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#countnonzero">org.opencv.core.Core.countNonZero</a>
             org.opencv.core.Core#minMaxLoc
             org.opencv.core.Core#calcCovarMatrix
             org.opencv.core.Core#meanStdDev
             org.opencv.core.Core#norm
             org.opencv.core.Core#mean
        </member>
        <member name="M:OpenCVUnity.Core.cubeRoot(System.Single)">
             <summary>Computes the cube root of an argument.</summary>
            
             <p>The function <code>cubeRoot</code> computes <em>sqrt3(val)</em>. Negative
             arguments are handled correctly. NaN and Inf are not handled. The accuracy
             approaches the maximum possible accuracy for single-precision data.</p>
            
             <param>val A function argument.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#cuberoot">org.opencv.core.Core.cubeRoot</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.dct(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.dct(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.determinant(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.dft(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.dft(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.divide(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Int32)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
             <param>scale scalar factor.</param>
             <param>dtype optional depth of the output array; if <code>-1</code>,
             <code>dst</code> will have depth <code>src2.depth()</code>, but in case of an
             array-by-array division, you can only pass <code>-1</code> when</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <member name="M:OpenCVUnity.Core.divide(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
             <param>scale scalar factor.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <member name="M:OpenCVUnity.Core.divide(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <member name="M:OpenCVUnity.Core.divide(System.Double,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>scale scalar factor.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
             <param>dtype optional depth of the output array; if <code>-1</code>,
             <code>dst</code> will have depth <code>src2.depth()</code>, but in case of an
             array-by-array division, you can only pass <code>-1</code> when
             <code>src1.depth()==src2.depth()</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <member name="M:OpenCVUnity.Core.divide(System.Double,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>scale scalar factor.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <member name="M:OpenCVUnity.Core.divide(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,System.Double,System.Int32)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
             <param>scale scalar factor.</param>
             <param>dtype optional depth of the output array; if <code>-1</code>,
             <code>dst</code> will have depth <code>src2.depth()</code>, but in case of an
             array-by-array division, you can only pass <code>-1</code> when</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <member name="M:OpenCVUnity.Core.divide(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,System.Double)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
             <param>scale scalar factor.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <member name="M:OpenCVUnity.Core.divide(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat)">
             <summary>Performs per-element division of two arrays or a scalar by an array.</summary>
            
             <p>The functions <code>divide</code> divide one array by another:</p>
            
             <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>
            
             <p>or a scalar by an array when there is no <code>src1</code> :</p>
            
             <p><em>dst(I) = saturate(scale/src2(I))</em></p>
            
             <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
             Different channels of multi-channel arrays are processed independently.</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src2</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>
             org.opencv.core.Core#multiply
             org.opencv.core.Core#add
             org.opencv.core.Core#subtract
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.eigen(OpenCVUnity.Mat,System.Boolean,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.exp(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the exponent of every array element.</summary>
            
             <p>The function <code>exp</code> calculates the exponent of every element of the
             input array:</p>
            
             <p><em>dst [I] = e^(src(I))</em></p>
            
             <p>The maximum relative error is about <code>7e-6</code> for single-precision
             input and less than <code>1e-10</code> for double-precision input. Currently,
             the function converts denormalized values to zeros on output. Special values
             (NaN, Inf) are not handled.</p>
            
             <param>src input array.</param>
             <param>dst output array of the same size and type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#exp">org.opencv.core.Core.exp</a>
             org.opencv.core.Core#log
             org.opencv.core.Core#cartToPolar
             org.opencv.core.Core#pow
             org.opencv.core.Core#sqrt
             org.opencv.core.Core#magnitude
             org.opencv.core.Core#polarToCart
             org.opencv.core.Core#phase
        </member>
        <member name="M:OpenCVUnity.Core.fastAtan2(System.Single,System.Single)">
             <summary>Calculates the angle of a 2D vector in degrees.</summary>
            
             <p>The function <code>fastAtan2</code> calculates the full-range angle of an
             input 2D vector. The angle is measured in degrees and varies from 0 to 360
             degrees. The accuracy is about 0.3 degrees.</p>
            
             <param>y y-coordinate of the vector.</param>
             <param>x x-coordinate of the vector.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#fastatan2">org.opencv.core.Core.fastAtan2</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.flip(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.gemm(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.gemm(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.gemm(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.getBuildInformation">
             <summary>Returns full configuration time cmake output.</summary>
            
             <p>Returned value is raw cmake output including version control system revision,
             compiler version, compiler flags, enabled modules and third party libraries,
             etc. Output format depends on target architecture.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getbuildinformation">org.opencv.core.Core.getBuildInformation</a>
        </member>
        <member name="M:OpenCVUnity.Core.getCPUTickCount">
             <summary>Returns the number of CPU ticks.</summary>
            
             <p>The function returns the current number of CPU ticks on some architectures
             (such as x86, x64, PowerPC). On other platforms the function is equivalent to
             <code>getTickCount</code>. It can also be used for very accurate time
             measurements, as well as for RNG initialization. Note that in case of
             multi-CPU systems a thread, from which <code>getCPUTickCount</code> is
             called, can be suspended and resumed at another CPU with its own counter. So,
             theoretically (and practically) the subsequent calls to the function do not
             necessary return the monotonously increasing values. Also, since a modern CPU
             varies the CPU frequency depending on the load, the number of CPU clocks
             spent in some code cannot be directly converted to time units. Therefore,
             <code>getTickCount</code> is generally a preferable solution for measuring
             execution time.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getcputickcount">org.opencv.core.Core.getCPUTickCount</a>
        </member>
        <member name="M:OpenCVUnity.Core.getNumberOfCPUs">
             <summary>Returns the number of logical CPUs available for the process.</summary>
            
             <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getnumberofcpus">org.opencv.core.Core.getNumberOfCPUs</a>
        </member>
        <member name="M:OpenCVUnity.Core.getOptimalDFTSize(System.Int32)">
             <summary>Returns the optimal DFT size for a given vector size.</summary>
            
             <p>DFT performance is not a monotonic function of a vector size. Therefore, when
             you calculate convolution of two arrays or perform the spectral analysis of
             an array, it usually makes sense to pad the input data with zeros to get a
             bit larger array that can be transformed much faster than the original one.
             Arrays whose size is a power-of-two (2, 4, 8, 16, 32,...) are the fastest to
             process. Though, the arrays whose size is a product of 2's, 3's, and 5's (for
             example, 300 = 5*5*3*2*2) are also processed quite efficiently.</p>
            
             <p>The function <code>getOptimalDFTSize</code> returns the minimum number
             <code>N</code> that is greater than or equal to <code>vecsize</code> so that
             the DFT of a vector of size <code>N</code> can be processed efficiently. In
             the current implementation <code>N</code> = 2^"p"/// 3^"q"/// 5^"r" for some
             integer <code>p</code>, <code>q</code>, <code>r</code>.</p>
            
             <p>The function returns a negative number if <code>vecsize</code> is too large
             (very close to <code>INT_MAX</code>).</p>
            
             <p>While the function cannot be used directly to estimate the optimal vector
             size for DCT transform (since the current DCT implementation supports only
             even-size vectors), it can be easily processed as <code>getOptimalDFTSize((vecsize+1)/2)*2</code>.</p>
            
             <param>vecsize vector size.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#getoptimaldftsize">org.opencv.core.Core.getOptimalDFTSize</a>
             org.opencv.core.Core#dft
             org.opencv.core.Core#dct
             org.opencv.core.Core#idct
             org.opencv.core.Core#mulSpectrums
             org.opencv.core.Core#idft
        </member>
        <member name="M:OpenCVUnity.Core.getTickCount">
             <summary>Returns the number of ticks.</summary>
            
             <p>The function returns the number of ticks after the certain event (for
             example, when the machine was turned on).
             It can be used to initialize "RNG" or to measure a function execution time by
             reading the tick count before and after the function call. See also the tick
             frequency.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#gettickcount">org.opencv.core.Core.getTickCount</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.getTickFrequency" -->
        <member name="M:OpenCVUnity.Core.idct(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)">
             <summary>Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</summary>
            
             <p><code>idct(src, dst, flags)</code> is equivalent to <code>dct(src, dst, flags
             | DCT_INVERSE)</code>.</p>
            
             <param>src input floating-point single-channel array.</param>
             <param>dst output array of the same size and type as <code>src</code>.</param>
             <param>flags operation flags.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idct">org.opencv.core.Core.idct</a>
             org.opencv.core.Core#dft
             org.opencv.core.Core#dct
             org.opencv.core.Core#getOptimalDFTSize
             org.opencv.core.Core#idft
        </member>
        <member name="M:OpenCVUnity.Core.idct(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</summary>
            
             <p><code>idct(src, dst, flags)</code> is equivalent to <code>dct(src, dst, flags
             | DCT_INVERSE)</code>.</p>
            
             <param>src input floating-point single-channel array.</param>
             <param>dst output array of the same size and type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idct">org.opencv.core.Core.idct</a>
             org.opencv.core.Core#dft
             org.opencv.core.Core#dct
             org.opencv.core.Core#getOptimalDFTSize
             org.opencv.core.Core#idft
        </member>
        <member name="M:OpenCVUnity.Core.idft(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)">
             <summary>Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</summary>
            
             <p><code>idft(src, dst, flags)</code> is equivalent to <code>dft(src, dst, flags
             | DFT_INVERSE)</code>.</p>
            
             <p>See "dft" for details.</p>
            
             <p>Note: None of <code>dft</code> and <code>idft</code> scales the result by
             default. So, you should pass <code>DFT_SCALE</code> to one of
             <code>dft</code> or <code>idft</code> explicitly to make these transforms
             mutually inverse.</p>
            
             <param>src input floating-point real or complex array.</param>
             <param>dst output array whose size and type depend on the <code>flags</code>.</param>
             <param>flags operation flags (see "dft").</param>
             <param>nonzeroRows number of <code>dst</code> rows to process; the rest of
             the rows have undefined content (see the convolution sample in "dft"
             description.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idft">org.opencv.core.Core.idft</a>
             org.opencv.core.Core#dft
             org.opencv.core.Core#dct
             org.opencv.core.Core#getOptimalDFTSize
             org.opencv.core.Core#idct
             org.opencv.core.Core#mulSpectrums
        </member>
        <member name="M:OpenCVUnity.Core.idft(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</summary>
            
             <p><code>idft(src, dst, flags)</code> is equivalent to <code>dft(src, dst, flags
             | DFT_INVERSE)</code>.</p>
            
             <p>See "dft" for details.</p>
            
             <p>Note: None of <code>dft</code> and <code>idft</code> scales the result by
             default. So, you should pass <code>DFT_SCALE</code> to one of
             <code>dft</code> or <code>idft</code> explicitly to make these transforms
             mutually inverse.</p>
            
             <param>src input floating-point real or complex array.</param>
             <param>dst output array whose size and type depend on the <code>flags</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idft">org.opencv.core.Core.idft</a>
             org.opencv.core.Core#dft
             org.opencv.core.Core#dct
             org.opencv.core.Core#getOptimalDFTSize
             org.opencv.core.Core#idct
             org.opencv.core.Core#mulSpectrums
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.inRange(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Scalar,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.invert(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <member name="M:OpenCVUnity.Core.invert(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Finds the inverse or pseudo-inverse of a matrix.</summary>
            
             <p>The function <code>invert</code> inverts the matrix <code>src</code> and
             stores the result in <code>dst</code>.
             When the matrix <code>src</code> is singular or non-square, the function
             calculates the pseudo-inverse matrix (the <code>dst</code> matrix) so that
             <code>norm(src*dst - I)</code> is minimal, where I is an identity matrix.</p>
            
             <p>In case of the <code>DECOMP_LU</code> method, the function returns non-zero
             value if the inverse has been successfully calculated and 0 if
             <code>src</code> is singular.</p>
            
             <p>In case of the <code>DECOMP_SVD</code> method, the function returns the
             inverse condition number of <code>src</code> (the ratio of the smallest
             singular value to the largest singular value) and 0 if <code>src</code> is
             singular. The SVD method calculates a pseudo-inverse matrix if
             <code>src</code> is singular.</p>
            
             <p>Similarly to <code>DECOMP_LU</code>, the method <code>DECOMP_CHOLESKY</code>
             works only with non-singular square matrices that should also be symmetrical
             and positively defined. In this case, the function stores the inverted matrix
             in <code>dst</code> and returns non-zero. Otherwise, it returns 0.</p>
            
             <param>src input floating-point <code>M x N</code> matrix.</param>
             <param>dst output matrix of <code>N x M</code> size and the same type as
             <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#invert">org.opencv.core.Core.invert</a>
             org.opencv.core.Core#solve
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.kmeans(OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.TermCriteria,System.Int32,System.Int32,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.kmeans(OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.TermCriteria,System.Int32,System.Int32)" -->
        <member name="M:OpenCVUnity.Core.log(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the natural logarithm of every array element.</summary>
            
             <p>The function <code>log</code> calculates the natural logarithm of the
             absolute value of every element of the input array:</p>
            
             <p><em>dst(I) = log|src(I)| if src(I) != 0 ; C otherwise</em></p>
            
             <p>where <code>C</code> is a large negative number (about -700 in the current
             implementation).
             The maximum relative error is about <code>7e-6</code> for single-precision
             input and less than <code>1e-10</code> for double-precision input. Special
             values (NaN, Inf) are not handled.</p>
            
             <param>src input array.</param>
             <param>dst output array of the same size and type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#log">org.opencv.core.Core.log</a>
             org.opencv.core.Core#cartToPolar
             org.opencv.core.Core#pow
             org.opencv.core.Core#sqrt
             org.opencv.core.Core#magnitude
             org.opencv.core.Core#polarToCart
             org.opencv.core.Core#exp
             org.opencv.core.Core#phase
        </member>
        <member name="M:OpenCVUnity.Core.magnitude(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the magnitude of 2D vectors.</summary>
            
             <p>The function <code>magnitude</code> calculates the magnitude of 2D vectors
             formed from the corresponding elements of <code>x</code> and <code>y</code>
             arrays:</p>
            
             <p><em>dst(I) = sqrt(x(I)^2 + y(I)^2)</em></p>
            
             <param>x floating-point array of x-coordinates of the vectors.</param>
             <param>y floating-point array of y-coordinates of the vectors; it must have
             the same size as <code>x</code>.</param>
             <param>magnitude output array of the same size and type as <code>x</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#magnitude">org.opencv.core.Core.magnitude</a>
             org.opencv.core.Core#cartToPolar
             org.opencv.core.Core#phase
             org.opencv.core.Core#sqrt
             org.opencv.core.Core#polarToCart
        </member>
        <member name="M:OpenCVUnity.Core.max(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates per-element maximum of two arrays or an array and a scalar.</summary>
            
             <p>The functions <code>max</code> calculate the per-element maximum of two
             arrays:</p>
            
             <p><em>dst(I)= max(src1(I), src2(I))</em></p>
            
             <p>or array and a scalar:</p>
            
             <p><em>dst(I)= max(src1(I), value)</em></p>
            
             <p>In the second variant, when the input array is multi-channel, each channel is
             compared with <code>value</code> independently.</p>
            
             <p>The first 3 variants of the function listed above are actually a part of
             "MatrixExpressions". They return an expression object that can be further
             either transformed/ assigned to a matrix, or passed to a function, and so on.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#max">org.opencv.core.Core.max</a>
             org.opencv.core.Core#compare
             org.opencv.core.Core#inRange
             org.opencv.core.Core#minMaxLoc
             org.opencv.core.Core#min
        </member>
        <member name="M:OpenCVUnity.Core.max(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat)">
             <summary>Calculates per-element maximum of two arrays or an array and a scalar.</summary>
            
             <p>The functions <code>max</code> calculate the per-element maximum of two
             arrays:</p>
            
             <p><em>dst(I)= max(src1(I), src2(I))</em></p>
            
             <p>or array and a scalar:</p>
            
             <p><em>dst(I)= max(src1(I), value)</em></p>
            
             <p>In the second variant, when the input array is multi-channel, each channel is
             compared with <code>value</code> independently.</p>
            
             <p>The first 3 variants of the function listed above are actually a part of
             "MatrixExpressions". They return an expression object that can be further
             either transformed/ assigned to a matrix, or passed to a function, and so on.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#max">org.opencv.core.Core.max</a>
             org.opencv.core.Core#compare
             org.opencv.core.Core#inRange
             org.opencv.core.Core#minMaxLoc
             org.opencv.core.Core#min
        </member>
        <member name="M:OpenCVUnity.Core.mean(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates an average (mean) of array elements.</summary>
            
             <p>The function <code>mean</code> calculates the mean value <code>M</code> of
             array elements, independently for each channel, and return it:</p>
            
             <p><em>N = sum(by: I: mask(I) != 0) 1
             M_c = (sum(by: I: mask(I) != 0)(mtx(I)_c))/N </em></p>
            
             <p>When all the mask elements are 0's, the functions return <code>Scalar.all(0)</code>.</p>
            
             <param>src input array that should have from 1 to 4 channels so that the
             result can be stored in "Scalar_".</param>
             <param>mask optional operation mask.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mean">org.opencv.core.Core.mean</a>
             org.opencv.core.Core#countNonZero
             org.opencv.core.Core#meanStdDev
             org.opencv.core.Core#norm
             org.opencv.core.Core#minMaxLoc
        </member>
        <member name="M:OpenCVUnity.Core.mean(OpenCVUnity.Mat)">
             <summary>Calculates an average (mean) of array elements.</summary>
            
             <p>The function <code>mean</code> calculates the mean value <code>M</code> of
             array elements, independently for each channel, and return it:</p>
            
             <p><em>N = sum(by: I: mask(I) != 0) 1
             M_c = (sum(by: I: mask(I) != 0)(mtx(I)_c))/N </em></p>
            
             <p>When all the mask elements are 0's, the functions return <code>Scalar.all(0)</code>.</p>
            
             <param>src input array that should have from 1 to 4 channels so that the
             result can be stored in "Scalar_".</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mean">org.opencv.core.Core.mean</a>
             org.opencv.core.Core#countNonZero
             org.opencv.core.Core#meanStdDev
             org.opencv.core.Core#norm
             org.opencv.core.Core#minMaxLoc
        </member>
        <member name="M:OpenCVUnity.Core.meanStdDev(OpenCVUnity.Mat,OpenCVUnity.MatOfDouble,OpenCVUnity.MatOfDouble,OpenCVUnity.Mat)">
             <summary>Calculates a mean and standard deviation of array elements.</summary>
            
             <p>The function <code>meanStdDev</code> calculates the mean and the standard
             deviation <code>M</code> of array elements independently for each channel and
             returns it via the output parameters:</p>
            
             <p><em>N = sum(by: I, mask(I) != 0) 1
             mean _c = (sum_(I: mask(I) != 0) src(I)_c)/(N)
             stddev _c = sqrt((sum_(I: mask(I) != 0)(src(I)_c - mean _c)^2)/(N)) </em></p>
            
             <p>When all the mask elements are 0's, the functions return <code>mean=stddev=Scalar.all(0)</code>.</p>
            
             <p>Note: The calculated standard deviation is only the diagonal of the complete
             normalized covariance matrix. If the full matrix is needed, you can reshape
             the multi-channel array <code>M x N</code> to the single-channel array
             <code>M*N x mtx.channels()</code> (only possible when the matrix is
             continuous) and then pass the matrix to "calcCovarMatrix".</p>
            
             <param>src input array that should have from 1 to 4 channels so that the
             results can be stored in "Scalar_" 's.</param>
             <param>mean output parameter: calculated mean value.</param>
             <param>stddev output parameter: calculateded standard deviation.</param>
             <param>mask optional operation mask.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#meanstddev">org.opencv.core.Core.meanStdDev</a>
             org.opencv.core.Core#countNonZero
             org.opencv.core.Core#calcCovarMatrix
             org.opencv.core.Core#minMaxLoc
             org.opencv.core.Core#norm
             org.opencv.core.Core#mean
        </member>
        <member name="M:OpenCVUnity.Core.meanStdDev(OpenCVUnity.Mat,OpenCVUnity.MatOfDouble,OpenCVUnity.MatOfDouble)">
             <summary>Calculates a mean and standard deviation of array elements.</summary>
            
             <p>The function <code>meanStdDev</code> calculates the mean and the standard
             deviation <code>M</code> of array elements independently for each channel and
             returns it via the output parameters:</p>
            
             <p><em>N = sum(by: I, mask(I) != 0) 1
             mean _c = (sum_(I: mask(I) != 0) src(I)_c)/(N)
             stddev _c = sqrt((sum_(I: mask(I) != 0)(src(I)_c - mean _c)^2)/(N)) </em></p>
            
             <p>When all the mask elements are 0's, the functions return <code>mean=stddev=Scalar.all(0)</code>.</p>
            
             <p>Note: The calculated standard deviation is only the diagonal of the complete
             normalized covariance matrix. If the full matrix is needed, you can reshape
             the multi-channel array <code>M x N</code> to the single-channel array
             <code>M*N x mtx.channels()</code> (only possible when the matrix is
             continuous) and then pass the matrix to "calcCovarMatrix".</p>
            
             <param>src input array that should have from 1 to 4 channels so that the
             results can be stored in "Scalar_" 's.</param>
             <param>mean output parameter: calculated mean value.</param>
             <param>stddev output parameter: calculateded standard deviation.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#meanstddev">org.opencv.core.Core.meanStdDev</a>
             org.opencv.core.Core#countNonZero
             org.opencv.core.Core#calcCovarMatrix
             org.opencv.core.Core#minMaxLoc
             org.opencv.core.Core#norm
             org.opencv.core.Core#mean
        </member>
        <member name="M:OpenCVUnity.Core.merge(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Mat)">
             <summary>Creates one multichannel array out of several single-channel ones.</summary>
            
             <p>The functions <code>merge</code> merge several arrays to make a single
             multi-channel array. That is, each element of the output array will be a
             concatenation of the elements of the input arrays, where elements of i-th
             input array are treated as <code>mv[i].channels()</code>-element vectors.</p>
            
             <p>The function "split" does the reverse operation. If you need to shuffle
             channels in some other advanced way, use "mixChannels".</p>
            
             <param>mv input array or vector of matrices to be merged; all the matrices in
             <code>mv</code> must have the same size and the same depth.</param>
             <param>dst output array of the same size and the same depth as
             <code>mv[0]</code>; The number of channels will be the total number of
             channels in the matrix array.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#merge">org.opencv.core.Core.merge</a>
             org.opencv.core.Mat#reshape
             org.opencv.core.Core#mixChannels
             org.opencv.core.Core#split
        </member>
        <member name="M:OpenCVUnity.Core.min(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates per-element minimum of two arrays or an array and a scalar.</summary>
            
             <p>The functions <code>min</code> calculate the per-element minimum of two
             arrays:</p>
            
             <p><em>dst(I)= min(src1(I), src2(I))</em></p>
            
             <p>or array and a scalar:</p>
            
             <p><em>dst(I)= min(src1(I), value)</em></p>
            
             <p>In the second variant, when the input array is multi-channel, each channel is
             compared with <code>value</code> independently.</p>
            
             <p>The first three variants of the function listed above are actually a part of
             "MatrixExpressions". They return the expression object that can be further
             either transformed/assigned to a matrix, or passed to a function, and so on.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#min">org.opencv.core.Core.min</a>
             org.opencv.core.Core#max
             org.opencv.core.Core#compare
             org.opencv.core.Core#inRange
             org.opencv.core.Core#minMaxLoc
        </member>
        <member name="M:OpenCVUnity.Core.min(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat)">
             <summary>Calculates per-element minimum of two arrays or an array and a scalar.</summary>
            
             <p>The functions <code>min</code> calculate the per-element minimum of two
             arrays:</p>
            
             <p><em>dst(I)= min(src1(I), src2(I))</em></p>
            
             <p>or array and a scalar:</p>
            
             <p><em>dst(I)= min(src1(I), value)</em></p>
            
             <p>In the second variant, when the input array is multi-channel, each channel is
             compared with <code>value</code> independently.</p>
            
             <p>The first three variants of the function listed above are actually a part of
             "MatrixExpressions". They return the expression object that can be further
             either transformed/assigned to a matrix, or passed to a function, and so on.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and type as <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#min">org.opencv.core.Core.min</a>
             org.opencv.core.Core#max
             org.opencv.core.Core#compare
             org.opencv.core.Core#inRange
             org.opencv.core.Core#minMaxLoc
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.mixChannels(System.Collections.Generic.List{OpenCVUnity.Mat},System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.MatOfInt)" -->
        <member name="M:OpenCVUnity.Core.mulSpectrums(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Boolean)">
             <summary>Performs the per-element multiplication of two Fourier spectrums.</summary>
            
             <p>The function <code>mulSpectrums</code> performs the per-element
             multiplication of the two CCS-packed or complex matrices that are results of
             a real or complex Fourier transform.</p>
            
             <p>The function, together with "dft" and "idft", may be used to calculate
             convolution (pass <code>conjB=false</code>) or correlation (pass
             <code>conjB=true</code>) of two arrays rapidly. When the arrays are complex,
             they are simply multiplied (per element) with an optional conjugation of the
             second-array elements. When the arrays are real, they are assumed to be
             CCS-packed (see "dft" for details).</p>
            
             <param>a a a</param>
             <param>b a b</param>
             <param>c a c</param>
             <param>flags operation flags; currently, the only supported flag is
             <code>DFT_ROWS</code>, which indicates that each row of <code>src1</code> and
             <code>src2</code> is an independent 1D Fourier spectrum.</param>
             <param>conjB optional flag that conjugates the second input array before the
             multiplication (true) or not (false).</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mulspectrums">org.opencv.core.Core.mulSpectrums</a>
        </member>
        <member name="M:OpenCVUnity.Core.mulSpectrums(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)">
             <summary>Performs the per-element multiplication of two Fourier spectrums.</summary>
            
             <p>The function <code>mulSpectrums</code> performs the per-element
             multiplication of the two CCS-packed or complex matrices that are results of
             a real or complex Fourier transform.</p>
            
             <p>The function, together with "dft" and "idft", may be used to calculate
             convolution (pass <code>conjB=false</code>) or correlation (pass
             <code>conjB=true</code>) of two arrays rapidly. When the arrays are complex,
             they are simply multiplied (per element) with an optional conjugation of the
             second-array elements. When the arrays are real, they are assumed to be
             CCS-packed (see "dft" for details).</p>
            
             <param>a a a</param>
             <param>b a b</param>
             <param>c a c</param>
             <param>flags operation flags; currently, the only supported flag is
             <code>DFT_ROWS</code>, which indicates that each row of <code>src1</code> and
             <code>src2</code> is an independent 1D Fourier spectrum.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mulspectrums">org.opencv.core.Core.mulSpectrums</a>
        </member>
        <member name="M:OpenCVUnity.Core.mulTransposed(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean,OpenCVUnity.Mat,System.Double,System.Int32)">
             <summary>Calculates the product of a matrix and its transposition.</summary>
            
             <p>The function <code>mulTransposed</code> calculates the product of
             <code>src</code> and its transposition:</p>
            
             <p><em>dst = scale(src - delta)^T(src - delta)</em></p>
            
             <p>if <code>aTa=true</code>, and</p>
            
             <p><em>dst = scale(src - delta)(src - delta)^T</em></p>
            
             <p>otherwise. The function is used to calculate the covariance matrix. With zero
             delta, it can be used as a faster substitute for general matrix product
             <code>A*B</code> when <code>B=A'</code></p>
            
             <param>src input single-channel matrix. Note that unlike "gemm", the function</param>
             can multiply not only floating-point matrices.
             <param>dst output square matrix.</param>
             <param>aTa Flag specifying the multiplication ordering. See the description</param>
             below.
             <param>delta Optional delta matrix subtracted from <code>src</code> before</param>
             the multiplication. When the matrix is empty (<code>delta=noArray()</code>),
             it is assumed to be zero, that is, nothing is subtracted. If it has the same
             size as <code>src</code>, it is simply subtracted. Otherwise, it is
             "repeated" (see "repeat") to cover the full <code>src</code> and then
             subtracted. Type of the delta matrix, when it is not empty, must be the same
             as the type of created output matrix. See the <code>dtype</code> parameter
             description below.
             <param>scale Optional scale factor for the matrix product.</param>
             <param>dtype Optional type of the output matrix. When it is negative, the</param>
             output matrix will have the same type as <code>src</code>. Otherwise, it will
             be <code>type=CV_MAT_DEPTH(dtype)</code> that should be either
             <code>CV_32F</code> or <code>CV_64F</code>.
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed">org.opencv.core.Core.mulTransposed</a>
             org.opencv.core.Core#calcCovarMatrix
             org.opencv.core.Core#repeat
             org.opencv.core.Core#reduce
             org.opencv.core.Core#gemm
        </member>
        <member name="M:OpenCVUnity.Core.mulTransposed(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean,OpenCVUnity.Mat,System.Double)">
             <summary>Calculates the product of a matrix and its transposition.</summary>
            
             <p>The function <code>mulTransposed</code> calculates the product of
             <code>src</code> and its transposition:</p>
            
             <p><em>dst = scale(src - delta)^T(src - delta)</em></p>
            
             <p>if <code>aTa=true</code>, and</p>
            
             <p><em>dst = scale(src - delta)(src - delta)^T</em></p>
            
             <p>otherwise. The function is used to calculate the covariance matrix. With zero
             delta, it can be used as a faster substitute for general matrix product
             <code>A*B</code> when <code>B=A'</code></p>
            
             <param>src input single-channel matrix. Note that unlike "gemm", the function
             can multiply not only floating-point matrices.</param>
             <param>dst output square matrix.</param>
             <param>aTa Flag specifying the multiplication ordering. See the description
             below.</param>
             <param>delta Optional delta matrix subtracted from <code>src</code> before
             the multiplication. When the matrix is empty (<code>delta=noArray()</code>),
             it is assumed to be zero, that is, nothing is subtracted. If it has the same
             size as <code>src</code>, it is simply subtracted. Otherwise, it is
             "repeated" (see "repeat") to cover the full <code>src</code> and then
             subtracted. Type of the delta matrix, when it is not empty, must be the same
             as the type of created output matrix. See the <code>dtype</code> parameter
             description below.</param>
             <param>scale Optional scale factor for the matrix product.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed">org.opencv.core.Core.mulTransposed</a>
             org.opencv.core.Core#calcCovarMatrix
             org.opencv.core.Core#repeat
             org.opencv.core.Core#reduce
             org.opencv.core.Core#gemm
        </member>
        <member name="M:OpenCVUnity.Core.mulTransposed(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean)">
             <summary>Calculates the product of a matrix and its transposition.</summary>
            
             <p>The function <code>mulTransposed</code> calculates the product of
             <code>src</code> and its transposition:</p>
            
             <p><em>dst = scale(src - delta)^T(src - delta)</em></p>
            
             <p>if <code>aTa=true</code>, and</p>
            
             <p><em>dst = scale(src - delta)(src - delta)^T</em></p>
            
             <p>otherwise. The function is used to calculate the covariance matrix. With zero
             delta, it can be used as a faster substitute for general matrix product
             <code>A*B</code> when <code>B=A'</code></p>
            
             <param>src input single-channel matrix. Note that unlike "gemm", the function
             can multiply not only floating-point matrices.</param>
             <param>dst output square matrix.</param>
             <param>aTa Flag specifying the multiplication ordering. See the description
             below.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed">org.opencv.core.Core.mulTransposed</a>
             org.opencv.core.Core#calcCovarMatrix
             org.opencv.core.Core#repeat
             org.opencv.core.Core#reduce
             org.opencv.core.Core#gemm
        </member>
        <member name="M:OpenCVUnity.Core.multiply(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Int32)">
             <summary>Calculates the per-element scaled product of two arrays.</summary>
            
             <p>The function <code>multiply</code> calculates the per-element product of two
             arrays:</p>
            
             <p><em>dst(I)= saturate(scale/// src1(I)/// src2(I))</em></p>
            
             <p>There is also a "MatrixExpressions" -friendly variant of the first function.
             See "Mat.mul".</p>
            
             <p>For a not-per-element matrix product, see "gemm".</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and the same type as</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
             <param>scale optional scale factor.</param>
             <param>dtype a dtype</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>
             org.opencv.core.Core#divide
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#addWeighted
             org.opencv.core.Core#add
             org.opencv.imgproc.Imgproc#accumulateSquare
             org.opencv.imgproc.Imgproc#accumulate
             org.opencv.core.Core#scaleAdd
             org.opencv.core.Core#subtract
             org.opencv.imgproc.Imgproc#accumulateProduct
        </member>
        <member name="M:OpenCVUnity.Core.multiply(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double)">
             <summary>Calculates the per-element scaled product of two arrays.</summary>
            
             <p>The function <code>multiply</code> calculates the per-element product of two
             arrays:</p>
            
             <p><em>dst(I)= saturate(scale/// src1(I)/// src2(I))</em></p>
            
             <p>There is also a "MatrixExpressions" -friendly variant of the first function.
             See "Mat.mul".</p>
            
             <p>For a not-per-element matrix product, see "gemm".</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and the same type as
             <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
             <param>scale optional scale factor.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>
             org.opencv.core.Core#divide
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#addWeighted
             org.opencv.core.Core#add
             org.opencv.imgproc.Imgproc#accumulateSquare
             org.opencv.imgproc.Imgproc#accumulate
             org.opencv.core.Core#scaleAdd
             org.opencv.core.Core#subtract
             org.opencv.imgproc.Imgproc#accumulateProduct
        </member>
        <member name="M:OpenCVUnity.Core.multiply(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the per-element scaled product of two arrays.</summary>
            
             <p>The function <code>multiply</code> calculates the per-element product of two
             arrays:</p>
            
             <p><em>dst(I)= saturate(scale/// src1(I)/// src2(I))</em></p>
            
             <p>There is also a "MatrixExpressions" -friendly variant of the first function.
             See "Mat.mul".</p>
            
             <p>For a not-per-element matrix product, see "gemm".</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and the same type as
             <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>
             org.opencv.core.Core#divide
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#addWeighted
             org.opencv.core.Core#add
             org.opencv.imgproc.Imgproc#accumulateSquare
             org.opencv.imgproc.Imgproc#accumulate
             org.opencv.core.Core#scaleAdd
             org.opencv.core.Core#subtract
             org.opencv.imgproc.Imgproc#accumulateProduct
        </member>
        <member name="M:OpenCVUnity.Core.multiply(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,System.Double,System.Int32)">
             <summary>Calculates the per-element scaled product of two arrays.</summary>
            
             <p>The function <code>multiply</code> calculates the per-element product of two
             arrays:</p>
            
             <p><em>dst(I)= saturate(scale/// src1(I)/// src2(I))</em></p>
            
             <p>There is also a "MatrixExpressions" -friendly variant of the first function.
             See "Mat.mul".</p>
            
             <p>For a not-per-element matrix product, see "gemm".</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and the same type as</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
             <param>scale optional scale factor.</param>
             <param>dtype a dtype</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>
             org.opencv.core.Core#divide
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#addWeighted
             org.opencv.core.Core#add
             org.opencv.imgproc.Imgproc#accumulateSquare
             org.opencv.imgproc.Imgproc#accumulate
             org.opencv.core.Core#scaleAdd
             org.opencv.core.Core#subtract
             org.opencv.imgproc.Imgproc#accumulateProduct
        </member>
        <member name="M:OpenCVUnity.Core.multiply(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,System.Double)">
             <summary>Calculates the per-element scaled product of two arrays.</summary>
            
             <p>The function <code>multiply</code> calculates the per-element product of two
             arrays:</p>
            
             <p><em>dst(I)= saturate(scale/// src1(I)/// src2(I))</em></p>
            
             <p>There is also a "MatrixExpressions" -friendly variant of the first function.
             See "Mat.mul".</p>
            
             <p>For a not-per-element matrix product, see "gemm".</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and the same type as
             <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
             <param>scale optional scale factor.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>
             org.opencv.core.Core#divide
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#addWeighted
             org.opencv.core.Core#add
             org.opencv.imgproc.Imgproc#accumulateSquare
             org.opencv.imgproc.Imgproc#accumulate
             org.opencv.core.Core#scaleAdd
             org.opencv.core.Core#subtract
             org.opencv.imgproc.Imgproc#accumulateProduct
        </member>
        <member name="M:OpenCVUnity.Core.multiply(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat)">
             <summary>Calculates the per-element scaled product of two arrays.</summary>
            
             <p>The function <code>multiply</code> calculates the per-element product of two
             arrays:</p>
            
             <p><em>dst(I)= saturate(scale/// src1(I)/// src2(I))</em></p>
            
             <p>There is also a "MatrixExpressions" -friendly variant of the first function.
             See "Mat.mul".</p>
            
             <p>For a not-per-element matrix product, see "gemm".</p>
            
             <p>Note: Saturation is not applied when the output array has the depth
             <code>CV_32S</code>. You may even get result of an incorrect sign in the case
             of overflow.</p>
            
             <param>src1 first input array.</param>
             <param>src2 second input array of the same size and the same type as
             <code>src1</code>.</param>
             <param>dst output array of the same size and type as <code>src1</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>
             org.opencv.core.Core#divide
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#addWeighted
             org.opencv.core.Core#add
             org.opencv.imgproc.Imgproc#accumulateSquare
             org.opencv.imgproc.Imgproc#accumulate
             org.opencv.core.Core#scaleAdd
             org.opencv.core.Core#subtract
             org.opencv.imgproc.Imgproc#accumulateProduct
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.norm(OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.norm(OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.norm(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.norm(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.norm(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.norm(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.normalize(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32,System.Int32,OpenCVUnity.Mat)">
             <summary>Normalizes the norm or value range of an array.</summary>
            
             <p>The functions <code>normalize</code> scale and shift the input array elements
             so that</p>
            
             <p><em>| dst|_(L_p)= alpha</em></p>
            
             <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
             or <code>NORM_L2</code>, respectively; or so that</p>
            
             <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>
            
             <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
             The optional mask specifies a sub-array to be normalized. This means that the
             norm or min-n-max are calculated over the sub-array, and then this sub-array
             is modified to be normalized. If you want to only use the mask to calculate
             the norm or min-max but modify the whole array, you can use "norm" and
             "Mat.convertTo".</p>
            
             <p>In case of sparse matrices, only the non-zero values are analyzed and
             transformed. Because of this, the range transformation for sparse matrices is
             not allowed since it can shift the zero level.</p>
            
             <param>src input array.</param>
             <param>dst output array of the same size as <code>src</code>.</param>
             <param>alpha norm value to normalize to or the lower range boundary in case</param>
             of the range normalization.
             <param>beta upper range boundary in case of the range normalization; it is</param>
             not used for the norm normalization.
             <param>norm_type a norm_type</param>
             <param>dtype when negative, the output array has the same type as</param>
             <code>src</code>; otherwise, it has the same number of channels as
             <code>src</code> and the depth <code>=CV_MAT_DEPTH(dtype)</code>.
             <param>mask optional operation mask.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#norm
        </member>
        <member name="M:OpenCVUnity.Core.normalize(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32,System.Int32)">
             <summary>Normalizes the norm or value range of an array.</summary>
            
             <p>The functions <code>normalize</code> scale and shift the input array elements
             so that</p>
            
             <p><em>| dst|_(L_p)= alpha</em></p>
            
             <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
             or <code>NORM_L2</code>, respectively; or so that</p>
            
             <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>
            
             <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
             The optional mask specifies a sub-array to be normalized. This means that the
             norm or min-n-max are calculated over the sub-array, and then this sub-array
             is modified to be normalized. If you want to only use the mask to calculate
             the norm or min-max but modify the whole array, you can use "norm" and
             "Mat.convertTo".</p>
            
             <p>In case of sparse matrices, only the non-zero values are analyzed and
             transformed. Because of this, the range transformation for sparse matrices is
             not allowed since it can shift the zero level.</p>
            
             <param>src input array.</param>
             <param>dst output array of the same size as <code>src</code>.</param>
             <param>alpha norm value to normalize to or the lower range boundary in case
             of the range normalization.</param>
             <param>beta upper range boundary in case of the range normalization; it is
             not used for the norm normalization.</param>
             <param>norm_type a norm_type</param>
             <param>dtype when negative, the output array has the same type as
             <code>src</code>; otherwise, it has the same number of channels as
             <code>src</code> and the depth <code>=CV_MAT_DEPTH(dtype)</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#norm
        </member>
        <member name="M:OpenCVUnity.Core.normalize(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32)">
             <summary>Normalizes the norm or value range of an array.</summary>
            
             <p>The functions <code>normalize</code> scale and shift the input array elements
             so that</p>
            
             <p><em>| dst|_(L_p)= alpha</em></p>
            
             <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
             or <code>NORM_L2</code>, respectively; or so that</p>
            
             <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>
            
             <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
             The optional mask specifies a sub-array to be normalized. This means that the
             norm or min-n-max are calculated over the sub-array, and then this sub-array
             is modified to be normalized. If you want to only use the mask to calculate
             the norm or min-max but modify the whole array, you can use "norm" and
             "Mat.convertTo".</p>
            
             <p>In case of sparse matrices, only the non-zero values are analyzed and
             transformed. Because of this, the range transformation for sparse matrices is
             not allowed since it can shift the zero level.</p>
            
             <param>src input array.</param>
             <param>dst output array of the same size as <code>src</code>.</param>
             <param>alpha norm value to normalize to or the lower range boundary in case
             of the range normalization.</param>
             <param>beta upper range boundary in case of the range normalization; it is
             not used for the norm normalization.</param>
             <param>norm_type a norm_type</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#norm
        </member>
        <member name="M:OpenCVUnity.Core.normalize(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Normalizes the norm or value range of an array.</summary>
            
             <p>The functions <code>normalize</code> scale and shift the input array elements
             so that</p>
            
             <p><em>| dst|_(L_p)= alpha</em></p>
            
             <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
             or <code>NORM_L2</code>, respectively; or so that</p>
            
             <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>
            
             <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
             The optional mask specifies a sub-array to be normalized. This means that the
             norm or min-n-max are calculated over the sub-array, and then this sub-array
             is modified to be normalized. If you want to only use the mask to calculate
             the norm or min-max but modify the whole array, you can use "norm" and
             "Mat.convertTo".</p>
            
             <p>In case of sparse matrices, only the non-zero values are analyzed and
             transformed. Because of this, the range transformation for sparse matrices is
             not allowed since it can shift the zero level.</p>
            
             <param>src input array.</param>
             <param>dst output array of the same size as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>
             org.opencv.core.Mat#convertTo
             org.opencv.core.Core#norm
        </member>
        <member name="M:OpenCVUnity.Core.perspectiveTransform(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Performs the perspective matrix transformation of vectors.</summary>
            
             <p>The function <code>perspectiveTransform</code> transforms every element of
             <code>src</code> by treating it as a 2D or 3D vector, in the following way:</p>
            
             <p><em>(x, y, z) -> (x'/w, y'/w, z'/w)</em></p>
            
             <p>where</p>
            
             <p><em>(x', y', z', w') = mat/// x y z 1 </em></p>
            
             <p>and</p>
            
             <p><em>w = w' if w' != 0; infty otherwise</em></p>
            
             <p>Here a 3D vector transformation is shown. In case of a 2D vector
             transformation, the <code>z</code> component is omitted.</p>
            
             <p>Note: The function transforms a sparse set of 2D or 3D vectors. If you want
             to transform an image using perspective transformation, use "warpPerspective".
             If you have an inverse problem, that is, you want to compute the most
             probable perspective transformation out of several pairs of corresponding
             points, you can use "getPerspectiveTransform" or "findHomography".</p>
            
             <param>src input two-channel or three-channel floating-point array; each
             element is a 2D/3D vector to be transformed.</param>
             <param>dst output array of the same size and type as <code>src</code>.</param>
             <param>m <code>3x3</code> or <code>4x4</code> floating-point transformation
             matrix.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#perspectivetransform">org.opencv.core.Core.perspectiveTransform</a>
             org.opencv.calib3d.Calib3d#findHomography
             org.opencv.imgproc.Imgproc#warpPerspective
             org.opencv.core.Core#transform
             org.opencv.imgproc.Imgproc#getPerspectiveTransform
        </member>
        <member name="M:OpenCVUnity.Core.phase(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean)">
             <summary>Calculates the rotation angle of 2D vectors.</summary>
            
             <p>The function <code>phase</code> calculates the rotation angle of each 2D
             vector that is formed from the corresponding elements of <code>x</code> and
             <code>y</code> :</p>
            
             <p><em>angle(I) = atan2(y(I), x(I))</em></p>
            
             <p>The angle estimation accuracy is about 0.3 degrees. When <code>x(I)=y(I)=0</code>,
             the corresponding <code>angle(I)</code> is set to 0.</p>
            
             <param>x input floating-point array of x-coordinates of 2D vectors.</param>
             <param>y input array of y-coordinates of 2D vectors; it must have the same
             size and the same type as <code>x</code>.</param>
             <param>angle output array of vector angles; it has the same size and same
             type as <code>x</code>.</param>
             <param>angleInDegrees when true, the function calculates the angle in
             degrees, otherwise, they are measured in radians.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#phase">org.opencv.core.Core.phase</a>
        </member>
        <member name="M:OpenCVUnity.Core.phase(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates the rotation angle of 2D vectors.</summary>
            
             <p>The function <code>phase</code> calculates the rotation angle of each 2D
             vector that is formed from the corresponding elements of <code>x</code> and
             <code>y</code> :</p>
            
             <p><em>angle(I) = atan2(y(I), x(I))</em></p>
            
             <p>The angle estimation accuracy is about 0.3 degrees. When <code>x(I)=y(I)=0</code>,
             the corresponding <code>angle(I)</code> is set to 0.</p>
            
             <param>x input floating-point array of x-coordinates of 2D vectors.</param>
             <param>y input array of y-coordinates of 2D vectors; it must have the same
             size and the same type as <code>x</code>.</param>
             <param>angle output array of vector angles; it has the same size and same
             type as <code>x</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#phase">org.opencv.core.Core.phase</a>
        </member>
        <member name="M:OpenCVUnity.Core.polarToCart(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean)">
             <summary>Calculates x and y coordinates of 2D vectors from their magnitude and angle.</summary>
            
             <p>The function <code>polarToCart</code> calculates the Cartesian coordinates of
             each 2D vector represented by the corresponding elements of <code>magnitude</code>
             and <code>angle</code> :</p>
            
             <p><em>x(I) = magnitude(I) cos(angle(I))
             y(I) = magnitude(I) sin(angle(I))
             </em></p>
            
             <p>The relative accuracy of the estimated coordinates is about <code>1e-6</code>.</p>
            
             <param>magnitude input floating-point array of magnitudes of 2D vectors; it
             can be an empty matrix (<code>=Mat()</code>), in this case, the function
             assumes that all the magnitudes are =1; if it is not empty, it must have the
             same size and type as <code>angle</code>.</param>
             <param>angle input floating-point array of angles of 2D vectors.</param>
             <param>x output array of x-coordinates of 2D vectors; it has the same size
             and type as <code>angle</code>.</param>
             <param>y output array of y-coordinates of 2D vectors; it has the same size
             and type as <code>angle</code>.</param>
             <param>angleInDegrees when true, the input angles are measured in degrees,
             otherwise, they are measured in radians.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#polartocart">org.opencv.core.Core.polarToCart</a>
             org.opencv.core.Core#log
             org.opencv.core.Core#cartToPolar
             org.opencv.core.Core#pow
             org.opencv.core.Core#sqrt
             org.opencv.core.Core#magnitude
             org.opencv.core.Core#exp
             org.opencv.core.Core#phase
        </member>
        <member name="M:OpenCVUnity.Core.polarToCart(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates x and y coordinates of 2D vectors from their magnitude and angle.</summary>
            
             <p>The function <code>polarToCart</code> calculates the Cartesian coordinates of
             each 2D vector represented by the corresponding elements of <code>magnitude</code>
             and <code>angle</code> :</p>
            
             <p><em>x(I) = magnitude(I) cos(angle(I))
             y(I) = magnitude(I) sin(angle(I))
             </em></p>
            
             <p>The relative accuracy of the estimated coordinates is about <code>1e-6</code>.</p>
            
             <param>magnitude input floating-point array of magnitudes of 2D vectors; it
             can be an empty matrix (<code>=Mat()</code>), in this case, the function
             assumes that all the magnitudes are =1; if it is not empty, it must have the
             same size and type as <code>angle</code>.</param>
             <param>angle input floating-point array of angles of 2D vectors.</param>
             <param>x output array of x-coordinates of 2D vectors; it has the same size
             and type as <code>angle</code>.</param>
             <param>y output array of y-coordinates of 2D vectors; it has the same size
             and type as <code>angle</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#polartocart">org.opencv.core.Core.polarToCart</a>
             org.opencv.core.Core#log
             org.opencv.core.Core#cartToPolar
             org.opencv.core.Core#pow
             org.opencv.core.Core#sqrt
             org.opencv.core.Core#magnitude
             org.opencv.core.Core#exp
             org.opencv.core.Core#phase
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.pow(OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.randn(OpenCVUnity.Mat,System.Double,System.Double)">
             <summary>Fills the array with normally distributed random numbers.</summary>
            
             <p>The function <code>randn</code> fills the matrix <code>dst</code> with
             normally distributed random numbers with the specified mean vector and the
             standard deviation matrix. The generated random numbers are clipped to fit
             the value range of the output array data type.</p>
            
             <param>dst output array of random numbers; the array must be pre-allocated
             and have 1 to 4 channels.</param>
             <param>mean mean value (expectation) of the generated random numbers.</param>
             <param>stddev standard deviation of the generated random numbers; it can be
             either a vector (in which case a diagonal standard deviation matrix is
             assumed) or a square matrix.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#randn">org.opencv.core.Core.randn</a>
             org.opencv.core.Core#randu
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.randu(OpenCVUnity.Mat,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.reduce(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.reduce(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <member name="M:OpenCVUnity.Core.repeat(OpenCVUnity.Mat,System.Int32,System.Int32,OpenCVUnity.Mat)">
             <summary>Fills the output array with repeated copies of the input array.</summary>
            
             <p>The functions "repeat" duplicate the input array one or more times along each
             of the two axes:</p>
            
             <p><em>dst _(ij)= src _(i mod src.rows, j mod src.cols)</em></p>
            
             <p>The second variant of the function is more convenient to use with
             "MatrixExpressions".</p>
            
             <param>src input array to replicate.</param>
             <param>ny Flag to specify how many times the <code>src</code> is repeated
             along the vertical axis.</param>
             <param>nx Flag to specify how many times the <code>src</code> is repeated
             along the horizontal axis.</param>
             <param>dst output array of the same type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#repeat">org.opencv.core.Core.repeat</a>
             org.opencv.core.Core#reduce
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.scaleAdd(OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.setIdentity(OpenCVUnity.Mat,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.setIdentity(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.solve(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <member name="M:OpenCVUnity.Core.solve(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Solves one or more linear systems or least-squares problems.</summary>
            
             <p>The function <code>solve</code> solves a linear system or least-squares
             problem (the latter is possible with SVD or QR methods, or by specifying the
             flag <code>DECOMP_NORMAL</code>):</p>
            
             <p><em>dst = arg min _X|src1/// X - src2|</em></p>
            
             <p>If <code>DECOMP_LU</code> or <code>DECOMP_CHOLESKY</code> method is used, the
             function returns 1 if <code>src1</code> (or <em>src1^Tsrc1</em>) is
             non-singular. Otherwise, it returns 0. In the latter case, <code>dst</code>
             is not valid. Other methods find a pseudo-solution in case of a singular
             left-hand side part.</p>
            
             <p>Note: If you want to find a unity-norm solution of an under-defined singular
             system <em>src1*dst=0</em>, the function <code>solve</code> will not do the
             work. Use "SVD.solveZ" instead.</p>
            
             <param>src1 input matrix on the left-hand side of the system.</param>
             <param>src2 input matrix on the right-hand side of the system.</param>
             <param>dst output solution.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solve">org.opencv.core.Core.solve</a>
             org.opencv.core.Core#invert
             org.opencv.core.Core#eigen
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.solveCubic(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.solvePoly(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)">
             <summary>Finds the real or complex roots of a polynomial equation.</summary>
            
             <p>The function <code>solvePoly</code> finds real and complex roots of a
             polynomial equation:</p>
            
             <p><em>coeffs [n] x^(n) + coeffs [n-1] x^(n-1) +... + coeffs [1] x + coeffs [0]
             = 0</em></p>
            
             <param>coeffs array of polynomial coefficients.</param>
             <param>roots output (complex) array of roots.</param>
             <param>maxIters maximum number of iterations the algorithm does.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvepoly">org.opencv.core.Core.solvePoly</a>
        </member>
        <member name="M:OpenCVUnity.Core.solvePoly(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Finds the real or complex roots of a polynomial equation.</summary>
            
             <p>The function <code>solvePoly</code> finds real and complex roots of a
             polynomial equation:</p>
            
             <p><em>coeffs [n] x^(n) + coeffs [n-1] x^(n-1) +... + coeffs [1] x + coeffs [0]
             = 0</em></p>
            
             <param>coeffs array of polynomial coefficients.</param>
             <param>roots output (complex) array of roots.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvepoly">org.opencv.core.Core.solvePoly</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.sort(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.sortIdx(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <member name="M:OpenCVUnity.Core.split(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.Mat})">
             <summary>Divides a multi-channel array into several single-channel arrays.</summary>
            
             <p>The functions <code>split</code> split a multi-channel array into separate
             single-channel arrays:</p>
            
             <p><em>mv [c](I) = src(I)_c</em></p>
            
             <p>If you need to extract a single channel or do some other sophisticated
             channel permutation, use "mixChannels".</p>
            
             <param>m a m</param>
             <param>mv output array or vector of arrays; in the first variant of the
             function the number of arrays must match <code>src.channels()</code>; the
             arrays themselves are reallocated, if needed.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#split">org.opencv.core.Core.split</a>
             org.opencv.core.Core#merge
             org.opencv.imgproc.Imgproc#cvtColor
             org.opencv.core.Core#mixChannels
        </member>
        <member name="M:OpenCVUnity.Core.sqrt(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Calculates a square root of array elements.</summary>
            
             <p>The functions <code>sqrt</code> calculate a square root of each input array
             element. In case of multi-channel arrays, each channel is processed
             independently. The accuracy is approximately the same as of the built-in
             <code>std.sqrt</code>.</p>
            
             <param>src input floating-point array.</param>
             <param>dst output array of the same size and type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sqrt">org.opencv.core.Core.sqrt</a>
             org.opencv.core.Core#pow
             org.opencv.core.Core#magnitude
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.subtract(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.subtract(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.subtract(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.subtract(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.subtract(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.subtract(OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Core.sumElems(OpenCVUnity.Mat)">
             <summary>Calculates the sum of array elements.</summary>
            
             <p>The functions <code>sum</code> calculate and return the sum of array
             elements, independently for each channel.</p>
            
             <param>src a src</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sum">org.opencv.core.Core.sum</a>
             org.opencv.core.Core#meanStdDev
             org.opencv.core.Core#reduce
             org.opencv.core.Core#minMaxLoc
             org.opencv.core.Core#countNonZero
             org.opencv.core.Core#norm
             org.opencv.core.Core#mean
        </member>
        <member name="M:OpenCVUnity.Core.trace(OpenCVUnity.Mat)">
             <summary>Returns the trace of a matrix.</summary>
            
             <p>The function <code>trace</code> returns the sum of the diagonal elements of
             the matrix <code>mtx</code>.</p>
            
             <p><em>tr(mtx) = sum _i mtx(i,i)</em></p>
            
             <param>mtx a mtx</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#trace">org.opencv.core.Core.trace</a>
        </member>
        <member name="M:OpenCVUnity.Core.transform(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Performs the matrix transformation of every array element.</summary>
            
             <p>The function <code>transform</code> performs the matrix transformation of
             every element of the array <code>src</code> and stores the results in
             <code>dst</code> :</p>
            
             <p><em>dst(I) = m/// src(I)</em></p>
            
             <p>(when <code>m.cols=src.channels()</code>), or</p>
            
             <p><em>dst(I) = m/// [ src(I); 1]</em></p>
            
             <p>(when <code>m.cols=src.channels()+1</code>)</p>
            
             <p>Every element of the <code>N</code> -channel array <code>src</code> is
             interpreted as <code>N</code> -element vector that is transformed using the
             <code>M x N</code> or <code>M x (N+1)</code> matrix <code>m</code> to
             <code>M</code>-element vector - the corresponding element of the output array
             <code>dst</code>.</p>
            
             <p>The function may be used for geometrical transformation of <code>N</code>
             -dimensional points, arbitrary linear color space transformation (such as
             various kinds of RGB to YUV transforms), shuffling the image channels, and so
             forth.</p>
            
             <param>src input array that must have as many channels (1 to 4) as
             <code>m.cols</code> or <code>m.cols-1</code>.</param>
             <param>dst output array of the same size and depth as <code>src</code>; it
             has as many channels as <code>m.rows</code>.</param>
             <param>m transformation <code>2x2</code> or <code>2x3</code> floating-point
             matrix.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#transform">org.opencv.core.Core.transform</a>
             org.opencv.imgproc.Imgproc#warpAffine
             org.opencv.core.Core#perspectiveTransform
             org.opencv.imgproc.Imgproc#warpPerspective
             org.opencv.imgproc.Imgproc#getAffineTransform
             org.opencv.video.Video#estimateRigidTransform
        </member>
        <member name="M:OpenCVUnity.Core.transpose(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Transposes a matrix.</summary>
            
             <p>The function "transpose" transposes the matrix <code>src</code> :</p>
            
             <p><em>dst(i,j) = src(j,i)</em></p>
            
             <p>Note: No complex conjugation is done in case of a complex matrix. It it
             should be done separately if needed.</p>
            
             <param>src input array.</param>
             <param>dst output array of the same type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#transpose">org.opencv.core.Core.transpose</a>
        </member>
        <member name="M:OpenCVUnity.Core.minMaxLoc(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Finds the global minimum and maximum in an array.</summary>
            
             <p>The functions <code>minMaxLoc</code> find the minimum and maximum element
             values and their positions. The extremums are searched across the whole array
             or, if <code>mask</code> is not an empty array, in the specified array
             region.</p>
            
             <p>The functions do not work with multi-channel arrays. If you need to find
             minimum or maximum elements across all the channels, use "Mat.reshape" first
             to reinterpret the array as single-channel. Or you may extract the particular
             channel using either "extractImageCOI", or "mixChannels", or "split".</p>
            
             <param>src input single-channel array.</param>
             <param>mask optional mask used to select a sub-array.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#minmaxloc">org.opencv.core.Core.minMaxLoc</a>
             org.opencv.core.Core#compare
             org.opencv.core.Core#min
             org.opencv.core.Core#mixChannels
             org.opencv.core.Mat#reshape
             org.opencv.core.Core#split
             org.opencv.core.Core#max
             org.opencv.core.Core#inRange
        </member>
        <member name="M:OpenCVUnity.Core.minMaxLoc(OpenCVUnity.Mat)">
             <summary>Finds the global minimum and maximum in an array.</summary>
            
             <p>The functions <code>minMaxLoc</code> find the minimum and maximum element
             values and their positions. The extremums are searched across the whole array
             or, if <code>mask</code> is not an empty array, in the specified array
             region.</p>
            
             <p>The functions do not work with multi-channel arrays. If you need to find
             minimum or maximum elements across all the channels, use "Mat.reshape" first
             to reinterpret the array as single-channel. Or you may extract the particular
             channel using either "extractImageCOI", or "mixChannels", or "split".</p>
            
             <param>src input single-channel array.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#minmaxloc">org.opencv.core.Core.minMaxLoc</a>
             org.opencv.core.Core#compare
             org.opencv.core.Core#min
             org.opencv.core.Core#mixChannels
             org.opencv.core.Mat#reshape
             org.opencv.core.Core#split
             org.opencv.core.Core#max
             org.opencv.core.Core#inRange
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.borderInterpolate(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.copyMakeBorder(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Core.copyMakeBorder(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="T:OpenCVUnity.Mat">
            <summary>
            Common logic element of OpenCV. Represents a many dimensional array of pixels.
            </summary>
        </member>
        <member name="M:OpenCVUnity.Mat.#ctor">
             <summary>Various Mat constructors</summary>
            
             <p>These are various constructors that form a matrix. As noted in the
             "AutomaticAllocation", often the default constructor is enough, and the
             proper matrix will be allocated by an OpenCV function. The constructed matrix
             can further be assigned to another matrix or matrix expression or can be
             allocated with "Mat.create". In the former case, the old content is
             de-referenced.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
        </member>
        <member name="M:OpenCVUnity.Mat.#ctor(System.Int32,System.Int32,System.Int32)">
             <summary>Various Mat constructors</summary>
            
             <p>These are various constructors that form a matrix. As noted in the
             "AutomaticAllocation", often the default constructor is enough, and the
             proper matrix will be allocated by an OpenCV function. The constructed matrix
             can further be assigned to another matrix or matrix expression or can be
             allocated with "Mat.create". In the former case, the old content is
             de-referenced.</p>
            
             <param>rows Number of rows in a 2D array.</param>
             <param>cols Number of columns in a 2D array.</param>
             <param>type Array type. Use <code>CV_8UC1,..., CV_64FC4</code> to create 1-4
             channel matrices, or <code>CV_8UC(n),..., CV_64FC(n)</code> to create
             multi-channel (up to <code>CV_CN_MAX</code> channels) matrices.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
        </member>
        <member name="M:OpenCVUnity.Mat.#ctor(OpenCVUnity.Size,System.Int32)">
             <summary>Various Mat constructors</summary>
            
             <p>These are various constructors that form a matrix. As noted in the
             "AutomaticAllocation", often the default constructor is enough, and the
             proper matrix will be allocated by an OpenCV function. The constructed matrix
             can further be assigned to another matrix or matrix expression or can be
             allocated with "Mat.create". In the former case, the old content is
             de-referenced.</p>
            
             <param>size 2D array size: <code>Size(cols, rows)</code>. In the
             <code>Size()</code> constructor, the number of rows and the number of columns
             go in the reverse order.</param>
             <param>type Array type. Use <code>CV_8UC1,..., CV_64FC4</code> to create 1-4
             channel matrices, or <code>CV_8UC(n),..., CV_64FC(n)</code> to create
             multi-channel (up to <code>CV_CN_MAX</code> channels) matrices.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.#ctor(System.Int32,System.Int32,System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.#ctor(OpenCVUnity.Size,System.Int32,OpenCVUnity.Scalar)" -->
        <member name="M:OpenCVUnity.Mat.#ctor(OpenCVUnity.Mat,OpenCVUnity.Range,OpenCVUnity.Range)">
             <summary>Various Mat constructors</summary>
            
             <p>These are various constructors that form a matrix. As noted in the
             "AutomaticAllocation", often the default constructor is enough, and the
             proper matrix will be allocated by an OpenCV function. The constructed matrix
             can further be assigned to another matrix or matrix expression or can be
             allocated with "Mat.create". In the former case, the old content is
             de-referenced.</p>
            
             <param>m Array that (as a whole or partly) is assigned to the constructed
             matrix. No data is copied by these constructors. Instead, the header pointing
             to <code>m</code> data or its sub-array is constructed and associated with
             it. The reference counter, if any, is incremented. So, when you modify the
             matrix formed using such a constructor, you also modify the corresponding
             elements of <code>m</code>. If you want to have an independent copy of the
             sub-array, use <code>Mat.clone()</code>.</param>
             <param>rowRange Range of the <code>m</code> rows to take. As usual, the range
             start is inclusive and the range end is exclusive. Use <code>Range.all()</code>
             to take all the rows.</param>
             <param>colRange Range of the <code>m</code> columns to take. Use
             <code>Range.all()</code> to take all the columns.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
        </member>
        <member name="M:OpenCVUnity.Mat.#ctor(OpenCVUnity.Mat,OpenCVUnity.Range)">
             <summary>Various Mat constructors</summary>
            
             <p>These are various constructors that form a matrix. As noted in the
             "AutomaticAllocation", often the default constructor is enough, and the
             proper matrix will be allocated by an OpenCV function. The constructed matrix
             can further be assigned to another matrix or matrix expression or can be
             allocated with "Mat.create". In the former case, the old content is
             de-referenced.</p>
            
             <param>m Array that (as a whole or partly) is assigned to the constructed
             matrix. No data is copied by these constructors. Instead, the header pointing
             to <code>m</code> data or its sub-array is constructed and associated with
             it. The reference counter, if any, is incremented. So, when you modify the
             matrix formed using such a constructor, you also modify the corresponding
             elements of <code>m</code>. If you want to have an independent copy of the
             sub-array, use <code>Mat.clone()</code>.</param>
             <param>rowRange Range of the <code>m</code> rows to take. As usual, the range
             start is inclusive and the range end is exclusive. Use <code>Range.all()</code>
             to take all the rows.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
        </member>
        <member name="M:OpenCVUnity.Mat.#ctor(OpenCVUnity.Mat,OpenCVUnity.Rect)">
             <summary>Various Mat constructors</summary>
            
             <p>These are various constructors that form a matrix. As noted in the
             "AutomaticAllocation", often the default constructor is enough, and the
             proper matrix will be allocated by an OpenCV function. The constructed matrix
             can further be assigned to another matrix or matrix expression or can be
             allocated with "Mat.create". In the former case, the old content is
             de-referenced.</p>
            
             <param>m Array that (as a whole or partly) is assigned to the constructed
             matrix. No data is copied by these constructors. Instead, the header pointing
             to <code>m</code> data or its sub-array is constructed and associated with
             it. The reference counter, if any, is incremented. So, when you modify the
             matrix formed using such a constructor, you also modify the corresponding
             elements of <code>m</code>. If you want to have an independent copy of the
             sub-array, use <code>Mat.clone()</code>.</param>
             <param>roi Region of interest.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.adjustROI(System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:OpenCVUnity.Mat.assignTo(OpenCVUnity.Mat,System.Int32)">
             <summary>Provides a functional form of <code>convertTo</code>.</summary>
            
             <p>This is an internally used method called by the "MatrixExpressions" engine.</p>
            
             <param>m Destination array.</param>
             <param>type Desired destination array depth (or -1 if it should be the same
             as the source type).</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-assignto">org.opencv.core.Mat.assignTo</a>
        </member>
        <member name="M:OpenCVUnity.Mat.assignTo(OpenCVUnity.Mat)">
             <summary>Provides a functional form of <code>convertTo</code>.</summary>
            
             <p>This is an internally used method called by the "MatrixExpressions" engine.</p>
            
             <param>m Destination array.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-assignto">org.opencv.core.Mat.assignTo</a>
        </member>
        <member name="M:OpenCVUnity.Mat.channels">
             <summary>Returns the number of matrix channels.</summary>
            
             <p>The method returns the number of matrix channels.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-channels">org.opencv.core.Mat.channels</a>
        </member>
        <member name="M:OpenCVUnity.Mat.clone">
             <summary>Creates a full copy of the array and the underlying data.</summary>
            
             <p>The method creates a full copy of the array. The original <code>step[]</code>
             is not taken into account. So, the array copy is a continuous array occupying
             <code>total()*elemSize()</code> bytes.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-clone">org.opencv.core.Mat.clone</a>
        </member>
        <member name="M:OpenCVUnity.Mat.col(System.Int32)">
             <summary>Creates a matrix header for the specified matrix column.</summary>
            
             <p>The method makes a new header for the specified matrix column and returns it.
             This is an O(1) operation, regardless of the matrix size. The underlying data
             of the new matrix is shared with the original matrix. See also the "Mat.row"
             description.</p>
            
             <param>x A 0-based column index.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-col">org.opencv.core.Mat.col</a>
        </member>
        <member name="M:OpenCVUnity.Mat.colRange(System.Int32,System.Int32)">
             <summary>Creates a matrix header for the specified column span.</summary>
            
             <p>The method makes a new header for the specified column span of the matrix.
             Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p>
            
             <param>startcol An inclusive 0-based start index of the column span.</param>
             <param>endcol An exclusive 0-based ending index of the column span.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-colrange">org.opencv.core.Mat.colRange</a>
        </member>
        <member name="M:OpenCVUnity.Mat.colRange(OpenCVUnity.Range)">
             <summary>Creates a matrix header for the specified column span.</summary>
            
             <p>The method makes a new header for the specified column span of the matrix.
             Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p>
            
             <param>r "Range" structure containing both the start and the end indices.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-colrange">org.opencv.core.Mat.colRange</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.convertTo(OpenCVUnity.Mat,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.convertTo(OpenCVUnity.Mat,System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.convertTo(OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.copyTo(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.copyTo(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.create(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.create(OpenCVUnity.Size,System.Int32)" -->
        <member name="M:OpenCVUnity.Mat.cross(OpenCVUnity.Mat)">
             <summary>Computes a cross-product of two 3-element vectors.</summary>
            
             <p>The method computes a cross-product of two 3-element vectors. The vectors
             must be 3-element floating-point vectors of the same shape and size. The
             result is another 3-element vector of the same shape and type as operands.</p>
            
             <param>m Another cross-product operand.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-cross">org.opencv.core.Mat.cross</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.depth" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.diag(System.Int32)" -->
        <member name="M:OpenCVUnity.Mat.diag">
             <summary>Extracts a diagonal from a matrix, or creates a diagonal matrix.</summary>
            
             <p>The method makes a new header for the specified matrix diagonal. The new
             matrix is represented as a single-column matrix. Similarly to "Mat.row" and
             "Mat.col", this is an O(1) operation.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-diag">org.opencv.core.Mat.diag</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.diag(OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Mat.dot(OpenCVUnity.Mat)">
             <summary>Computes a dot-product of two vectors.</summary>
            
             <p>The method computes a dot-product of two matrices. If the matrices are not
             single-column or single-row vectors, the top-to-bottom left-to-right scan
             ordering is used to treat them as 1D vectors. The vectors must have the same
             size and type. If the matrices have more than one channel, the dot products
             from all the channels are summed together.</p>
            
             <param>m another dot-product operand.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-dot">org.opencv.core.Mat.dot</a>
        </member>
        <member name="M:OpenCVUnity.Mat.elemSize">
             <summary>Returns the matrix element size in bytes.</summary>
            
             <p>The method returns the matrix element size in bytes. For example, if the
             matrix type is <code>CV_16SC3</code>, the method returns <code>3*sizeof(short)</code>
             or 6.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-elemsize">org.opencv.core.Mat.elemSize</a>
        </member>
        <member name="M:OpenCVUnity.Mat.elemSize1">
             <summary>Returns the size of each matrix element channel in bytes.</summary>
            
             <p>The method returns the matrix element channel size in bytes, that is, it
             ignores the number of channels. For example, if the matrix type is
             <code>CV_16SC3</code>, the method returns <code>sizeof(short)</code> or 2.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-elemsize1">org.opencv.core.Mat.elemSize1</a>
        </member>
        <member name="M:OpenCVUnity.Mat.empty">
             <summary>Returns <code>true</code> if the array has no elements.</summary>
            
             <p>The method returns <code>true</code> if <code>Mat.total()</code> is 0 or if
             <code>Mat.data</code> is NULL. Because of <code>pop_back()</code> and
             <code>resize()</code> methods <code>M.total() == 0</code> does not imply that
             <code>M.data == NULL</code>.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-empty">org.opencv.core.Mat.empty</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.eye(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.eye(OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.inv(System.Int32)" -->
        <member name="M:OpenCVUnity.Mat.inv">
             <summary>Inverses a matrix.</summary>
            
             <p>The method performs a matrix inversion by means of matrix expressions. This
             means that a temporary matrix inversion object is returned by the method and
             can be used further as a part of more complex matrix expressions or can be
             assigned to a matrix.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-inv">org.opencv.core.Mat.inv</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.isContinuous" -->
        <member name="M:OpenCVUnity.Mat.locateROI(OpenCVUnity.Size,OpenCVUnity.Point)">
             <summary>Locates the matrix header within a parent matrix.</summary>
            
             <p>After you extracted a submatrix from a matrix using "Mat.row", "Mat.col",
             "Mat.rowRange", "Mat.colRange", and others, the resultant submatrix points
             just to the part of the original big matrix. However, each submatrix contains
             information (represented by <code>datastart</code> and <code>dataend</code>
             fields) that helps reconstruct the original matrix size and the position of
             the extracted submatrix within the original matrix. The method
             <code>locateROI</code> does exactly that.</p>
            
             <param>wholeSize Output parameter that contains the size of the whole matrix
             containing <code>*this</code> as a part.</param>
             <param>ofs Output parameter that contains an offset of <code>*this</code>
             inside the whole matrix.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-locateroi">org.opencv.core.Mat.locateROI</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.mul(OpenCVUnity.Mat,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.mul(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.ones(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.ones(OpenCVUnity.Size,System.Int32)" -->
        <member name="M:OpenCVUnity.Mat.push_back(OpenCVUnity.Mat)">
             <summary>Adds elements to the bottom of the matrix.</summary>
            
             <p>The methods add one or more elements to the bottom of the matrix. They
             emulate the corresponding method of the STL vector class. When
             <code>elem</code> is <code>Mat</code>, its type and the number of columns
             must be the same as in the container matrix.</p>
            
             <param>m Added line(s).</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-push-back">org.opencv.core.Mat.push_back</a>
        </member>
        <member name="M:OpenCVUnity.Mat.release">
             <summary>Decrements the reference counter and deallocates the matrix if needed.</summary>
            
             <p>The method decrements the reference counter associated with the matrix data.
             When the reference counter reaches 0, the matrix data is deallocated and the
             data and the reference counter pointers are set to NULL's. If the matrix
             header points to an external data set (see "Mat.Mat"), the reference counter
             is NULL, and the method has no effect in this case.</p>
            
             <p>This method can be called manually to force the matrix data deallocation. But
             since this method is automatically called in the destructor, or by any other
             method that changes the data pointer, it is usually not needed. The reference
             counter decrement and check for 0 is an atomic operation on the platforms
             that support it. Thus, it is safe to operate on the same matrices
             asynchronously in different threads.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-release">org.opencv.core.Mat.release</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.reshape(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.reshape(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.row(System.Int32)" -->
        <member name="M:OpenCVUnity.Mat.rowRange(System.Int32,System.Int32)">
             <summary>Creates a matrix header for the specified row span.</summary>
            
             <p>The method makes a new header for the specified row span of the matrix.
             Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p>
            
             <param>startrow An inclusive 0-based start index of the row span.</param>
             <param>endrow An exclusive 0-based ending index of the row span.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-rowrange">org.opencv.core.Mat.rowRange</a>
        </member>
        <member name="M:OpenCVUnity.Mat.rowRange(OpenCVUnity.Range)">
             <summary>Creates a matrix header for the specified row span.</summary>
            
             <p>The method makes a new header for the specified row span of the matrix.
             Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p>
            
             <param>r "Range" structure containing both the start and the end indices.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-rowrange">org.opencv.core.Mat.rowRange</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.setTo(OpenCVUnity.Scalar,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.setTo(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Mat.setTo(OpenCVUnity.Mat)">
             <summary>Sets all or some of the array elements to the specified value.</summary>
            
             <param>value Assigned scalar converted to the actual array type.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-setto">org.opencv.core.Mat.setTo</a>
        </member>
        <member name="M:OpenCVUnity.Mat.size">
             <summary>Returns a matrix size.</summary>
            
             <p>The method returns a matrix size: <code>Size(cols, rows)</code>. When the
             matrix is more than 2-dimensional, the returned size is (-1, -1).</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-size">org.opencv.core.Mat.size</a>
        </member>
        <member name="M:OpenCVUnity.Mat.step1(System.Int32)">
             <summary>Returns a normalized step.</summary>
            
             <p>The method returns a matrix step divided by "Mat.elemSize1()". It can be
             useful to quickly access an arbitrary matrix element.</p>
            
             <param>i a i</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-step1">org.opencv.core.Mat.step1</a>
        </member>
        <member name="M:OpenCVUnity.Mat.step1">
             <summary>Returns a normalized step.</summary>
            
             <p>The method returns a matrix step divided by "Mat.elemSize1()". It can be
             useful to quickly access an arbitrary matrix element.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-step1">org.opencv.core.Mat.step1</a>
        </member>
        <member name="M:OpenCVUnity.Mat.submat(System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>Extracts a rectangular submatrix.</summary>
            
             <p>The operators make a new header for the specified sub-array of
             <code>*this</code>. They are the most generalized forms of "Mat.row",
             "Mat.col", "Mat.rowRange", and "Mat.colRange". For example,
             <code>A(Range(0, 10), Range.all())</code> is equivalent to <code>A.rowRange(0,
             10)</code>. Similarly to all of the above, the operators are O(1) operations,
             that is, no matrix data is copied.</p>
            
             <param>rowStart a rowStart</param>
             <param>rowEnd a rowEnd</param>
             <param>colStart a colStart</param>
             <param>colEnd a colEnd</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator">org.opencv.core.Mat.operator()</a>
        </member>
        <member name="M:OpenCVUnity.Mat.submat(OpenCVUnity.Range,OpenCVUnity.Range)">
             <summary>Extracts a rectangular submatrix.</summary>
            
             <p>The operators make a new header for the specified sub-array of
             <code>*this</code>. They are the most generalized forms of "Mat.row",
             "Mat.col", "Mat.rowRange", and "Mat.colRange". For example,
             <code>A(Range(0, 10), Range.all())</code> is equivalent to <code>A.rowRange(0,
             10)</code>. Similarly to all of the above, the operators are O(1) operations,
             that is, no matrix data is copied.</p>
            
             <param>rowRange Start and end row of the extracted submatrix. The upper
             boundary is not included. To select all the rows, use <code>Range.all()</code>.</param>
             <param>colRange Start and end column of the extracted submatrix. The upper
             boundary is not included. To select all the columns, use <code>Range.all()</code>.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator">org.opencv.core.Mat.operator()</a>
        </member>
        <member name="M:OpenCVUnity.Mat.submat(OpenCVUnity.Rect)">
             <summary>Extracts a rectangular submatrix.</summary>
            
             <p>The operators make a new header for the specified sub-array of
             <code>*this</code>. They are the most generalized forms of "Mat.row",
             "Mat.col", "Mat.rowRange", and "Mat.colRange". For example,
             <code>A(Range(0, 10), Range.all())</code> is equivalent to <code>A.rowRange(0,
             10)</code>. Similarly to all of the above, the operators are O(1) operations,
             that is, no matrix data is copied.</p>
            
             <param>roi Extracted submatrix specified as a rectangle.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator">org.opencv.core.Mat.operator()</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.t" -->
        <member name="M:OpenCVUnity.Mat.total">
             <summary>Returns the total number of array elements.</summary>
            
             <p>The method returns the number of array elements (a number of pixels if the
             array represents an image).</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-total">org.opencv.core.Mat.total</a>
        </member>
        <member name="M:OpenCVUnity.Mat.type">
             <summary>Returns the type of a matrix element.</summary>
            
             <p>The method returns a matrix element type. This is an identifier compatible
             with the <code>CvMat</code> type system, like <code>CV_16SC3</code> or 16-bit
             signed 3-channel array, and so on.</p>
            
             <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-type">org.opencv.core.Mat.type</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.zeros(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Mat.zeros(OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.Point" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.Point3" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.Range" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.Rect" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.Scalar" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.Size" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.TermCriteria" -->
        <member name="F:OpenCVUnity.TermCriteria.COUNT">
            The maximum number of iterations or elements to compute
        </member>
        <member name="F:OpenCVUnity.TermCriteria.MAX_ITER">
            The maximum number of iterations or elements to compute
        </member>
        <member name="F:OpenCVUnity.TermCriteria.EPS">
            The desired accuracy threshold or change in parameters at which the iterative algorithm is terminated.
        </member>
        <member name="M:OpenCVUnity.TermCriteria.#ctor(System.Int32,System.Int32,System.Double)">
             Termination criteria for iterative algorithms.
            
             <param>type the type of termination criteria: COUNT, EPS or COUNT + EPS. </param>
             <param>maxCount the maximum number of iterations/elements. </param>
             <param>epsilon the desired accuracy. </param>
        </member>
        <member name="M:OpenCVUnity.TermCriteria.#ctor">
            Termination criteria for iterative algorithms.
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.DescriptorExtractor" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.DescriptorExtractor.create(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.DescriptorMatcher" -->
        <member name="M:OpenCVUnity.DescriptorMatcher.create(System.Int32)">
             <summary>Creates a descriptor matcher of a given type with the default parameters
             (using default constructor).</summary>
            
             <param>matcherType a matcherType</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#descriptormatcher-create">org.opencv.features2d.DescriptorMatcher.create</a>
        </member>
        <member name="F:OpenCVUnity.DMatch.queryIdx">
            Query descriptor index.
        </member>
        <member name="F:OpenCVUnity.DMatch.trainIdx">
            Train descriptor index.
        </member>
        <member name="F:OpenCVUnity.DMatch.imgIdx">
            Train image index.
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.FeatureDetector" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.FeatureDetector.create(System.Int32)" -->
        <member name="M:OpenCVUnity.Features2d.drawKeypoints(OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.Mat,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws keypoints.</summary>
            
             <param>image Source image.</param>
             <param>keypoints Keypoints from the source image.</param>
             <param>outImage Output image. Its content depends on the <code>flags</code>
             value defining what is drawn in the output image. See possible
             <code>flags</code> bit values below.</param>
             <param>color Color of keypoints.</param>
             <param>flags Flags setting drawing features. Possible <code>flags</code> bit
             values are defined by <code>DrawMatchesFlags</code>. See details above in
             "drawMatches".</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#drawkeypoints">org.opencv.features2d.Features2d.drawKeypoints</a>
        </member>
        <member name="M:OpenCVUnity.Features2d.drawKeypoints(OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.Mat)">
             <summary>Draws keypoints.</summary>
            
             <param>image Source image.</param>
             <param>keypoints Keypoints from the source image.</param>
             <param>outImage Output image. Its content depends on the <code>flags</code>
             value defining what is drawn in the output image. See possible
             <code>flags</code> bit values below.</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#drawkeypoints">org.opencv.features2d.Features2d.drawKeypoints</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Features2d.drawMatches(OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.MatOfDMatch,OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Scalar,OpenCVUnity.MatOfByte,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Features2d.drawMatches(OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.MatOfDMatch,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Features2d.drawMatches2(OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,System.Collections.Generic.List{OpenCVUnity.MatOfDMatch},OpenCVUnity.Mat,OpenCVUnity.Scalar,OpenCVUnity.Scalar,System.Collections.Generic.List{OpenCVUnity.MatOfByte},System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Features2d.drawMatches2(OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,OpenCVUnity.Mat,OpenCVUnity.MatOfKeyPoint,System.Collections.Generic.List{OpenCVUnity.MatOfDMatch},OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.GenericDescriptorMatcher" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.KeyPoint" -->
        <member name="F:OpenCVUnity.KeyPoint.pt">
            Coordinates of the keypoint.
        </member>
        <member name="F:OpenCVUnity.KeyPoint.size">
            Diameter of the useful keypoint adjacent area.
        </member>
        <member name="F:OpenCVUnity.KeyPoint.angle">
            Computed orientation of the keypoint (-1 if not applicable).
        </member>
        <member name="F:OpenCVUnity.KeyPoint.response">
            The response, by which the strongest keypoints have been selected. Can
            be used for further sorting or subsampling.
        </member>
        <member name="F:OpenCVUnity.KeyPoint.octave">
            Octave (pyramid layer), from which the keypoint has been extracted.
        </member>
        <member name="F:OpenCVUnity.KeyPoint.class_id">
            Object ID, that can be used to cluster keypoints by an object they
            belong to.
        </member>
        <member name="M:OpenCVUnity.KeyPoint.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
             <summary>The keypoint constructors</summary>
            
             <param>x x-coordinate of the keypoint</param>
             <param>y y-coordinate of the keypoint</param>
             <param>_size keypoint diameter</param>
             <param>_angle keypoint orientation</param>
             <param>_response keypoint detector response on the keypoint (that is,
             strength of the keypoint)</param>
             <param>_octave pyramid octave in which the keypoint has been detected</param>
             <param>_class_id object id</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_feature_detectors.html#keypoint-keypoint">org.opencv.features2d.KeyPoint.KeyPoint</a>
        </member>
        <member name="M:OpenCVUnity.KeyPoint.#ctor">
             <summary>The keypoint constructors</summary>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_feature_detectors.html#keypoint-keypoint">org.opencv.features2d.KeyPoint.KeyPoint</a>
        </member>
        <member name="M:OpenCVUnity.KeyPoint.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
             <summary>The keypoint constructors</summary>
            
             <param>x x-coordinate of the keypoint</param>
             <param>y y-coordinate of the keypoint</param>
             <param>_size keypoint diameter</param>
             <param>_angle keypoint orientation</param>
             <param>_response keypoint detector response on the keypoint (that is,
             strength of the keypoint)</param>
             <param>_octave pyramid octave in which the keypoint has been detected</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_feature_detectors.html#keypoint-keypoint">org.opencv.features2d.KeyPoint.KeyPoint</a>
        </member>
        <member name="M:OpenCVUnity.KeyPoint.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
             <summary>The keypoint constructors</summary>
            
             <param>x x-coordinate of the keypoint</param>
             <param>y y-coordinate of the keypoint</param>
             <param>_size keypoint diameter</param>
             <param>_angle keypoint orientation</param>
             <param>_response keypoint detector response on the keypoint (that is,
             strength of the keypoint)</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_feature_detectors.html#keypoint-keypoint">org.opencv.features2d.KeyPoint.KeyPoint</a>
        </member>
        <member name="M:OpenCVUnity.KeyPoint.#ctor(System.Single,System.Single,System.Single,System.Single)">
             <summary>The keypoint constructors</summary>
            
             <param>x x-coordinate of the keypoint</param>
             <param>y y-coordinate of the keypoint</param>
             <param>_size keypoint diameter</param>
             <param>_angle keypoint orientation</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_feature_detectors.html#keypoint-keypoint">org.opencv.features2d.KeyPoint.KeyPoint</a>
        </member>
        <member name="M:OpenCVUnity.KeyPoint.#ctor(System.Single,System.Single,System.Single)">
             <summary>The keypoint constructors</summary>
            
             <param>x x-coordinate of the keypoint</param>
             <param>y y-coordinate of the keypoint</param>
             <param>_size keypoint diameter</param>
            
             <a href="http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_feature_detectors.html#keypoint-keypoint">org.opencv.features2d.KeyPoint.KeyPoint</a>
        </member>
        <member name="M:OpenCVUnity.Highgui.imdecode(OpenCVUnity.Mat,System.Int32)">
             <summary>Reads an image from a buffer in memory.</summary>
            
             <p>The function reads an image from the specified buffer in the memory.
             If the buffer is too short or contains invalid data, the empty matrix/image
             is returned.</p>
            
             <p>See "imread" for the list of supported formats and flags description.</p>
            
             <p>Note: In the case of color images, the decoded images will have the channels
             stored in <code>B G R</code> order.</p>
            
             <param>buf Input array or vector of bytes.</param>
             <param>flags The same flags as in "imread".</param>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#imdecode">org.opencv.highgui.Highgui.imdecode</a>
        </member>
        <member name="M:OpenCVUnity.Highgui.imencode(System.String,OpenCVUnity.Mat,OpenCVUnity.MatOfByte,OpenCVUnity.MatOfInt)">
             <summary>Encodes an image into a memory buffer.</summary>
            
             <p>The function compresses the image and stores it in the memory buffer that is
             resized to fit the result.
             See "imwrite" for the list of supported formats and flags description.</p>
            
             <p>Note: <code>cvEncodeImage</code> returns single-row matrix of type
             <code>CV_8UC1</code> that contains encoded image as array of bytes.</p>
            
             <param>ext File extension that defines the output format.</param>
             <param>img Image to be written.</param>
             <param>buf Output buffer resized to fit the compressed image.</param>
             <param>params Format-specific parameters. See "imwrite".</param>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#imencode">org.opencv.highgui.Highgui.imencode</a>
        </member>
        <member name="M:OpenCVUnity.Highgui.imencode(System.String,OpenCVUnity.Mat,OpenCVUnity.MatOfByte)">
             <summary>Encodes an image into a memory buffer.</summary>
            
             <p>The function compresses the image and stores it in the memory buffer that is
             resized to fit the result.
             See "imwrite" for the list of supported formats and flags description.</p>
            
             <p>Note: <code>cvEncodeImage</code> returns single-row matrix of type
             <code>CV_8UC1</code> that contains encoded image as array of bytes.</p>
            
             <param>ext File extension that defines the output format.</param>
             <param>img Image to be written.</param>
             <param>buf Output buffer resized to fit the compressed image.</param>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#imencode">org.opencv.highgui.Highgui.imencode</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Highgui.imread(System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Highgui.imread(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Highgui.imwrite(System.String,OpenCVUnity.Mat,OpenCVUnity.MatOfInt)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Highgui.imwrite(System.String,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.VideoCapture" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.VideoCapture.#ctor" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.VideoCapture.#ctor(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.VideoCapture.#ctor(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.VideoCapture.get(System.Int32)" -->
        <member name="M:OpenCVUnity.VideoCapture.grab">
             <summary>Grabs the next frame from video file or capturing device.</summary>
            
             <p>The methods/functions grab the next frame from video file or camera and
             return true (non-zero) in the case of success.</p>
            
             <p>The primary use of the function is in multi-camera environments, especially
             when the cameras do not have hardware synchronization. That is, you call
             <code>VideoCapture.grab()</code> for each camera and after that call the
             slower method <code>VideoCapture.retrieve()</code> to decode and get frame
             from each camera. This way the overhead on demosaicing or motion jpeg
             decompression etc. is eliminated and the retrieved frames from different
             cameras will be closer in time.</p>
            
             <p>Also, when a connected camera is multi-head (for example, a stereo camera or
             a Kinect device), the correct way of retrieving data from it is to call
             "VideoCapture.grab" first and then call "VideoCapture.retrieve" one or more
             times with different values of the <code>channel</code> parameter. See
             https://github.com/Itseez/opencv/tree/master/samples/cpp/openni_capture.cpp</p>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-grab">org.opencv.highgui.VideoCapture.grab</a>
        </member>
        <member name="M:OpenCVUnity.VideoCapture.isOpened">
             <summary>Returns true if video capturing has been initialized already.</summary>
            
             <p>If the previous call to <code>VideoCapture</code> constructor or
             <code>VideoCapture.open</code> succeeded, the method returns true.</p>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-isopened">org.opencv.highgui.VideoCapture.isOpened</a>
        </member>
        <member name="M:OpenCVUnity.VideoCapture.open(System.String)">
             (Support for Win,Mac,iOS)
             Win Setup
             1)Download "OpenCV for Windows Version 2.4.9"(http://opencv.org/downloads.html).
             2)Set Path to "opencv_ffmpeg249.dll"
               if 32bit, "C:\opencv\build\x86\vc10\bin\".
               if 64bit, "C:\opencv\build\x64\vc10\bin\".
             <p>Open video file or a capturing device for video capturing</p>
            
             <p>The methods first call "VideoCapture.release" to close the already opened
             file or camera.</p>
            
             <param>filename name of the opened video file (eg. video.avi) or image</param>
             sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg,
             img_01.jpg, img_02.jpg,...)
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-open">org.opencv.highgui.VideoCapture.open</a>
        </member>
        <member name="M:OpenCVUnity.VideoCapture.open(System.Int32)">
             <summary>Open video file or a capturing device for video capturing</summary>
            
             <p>The methods first call "VideoCapture.release" to close the already opened
             file or camera.</p>
            
             <param>device id of the opened video capturing device (i.e. a camera index).</param>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-open">org.opencv.highgui.VideoCapture.open</a>
        </member>
        <member name="M:OpenCVUnity.VideoCapture.read(OpenCVUnity.Mat)">
             <summary>Grabs, decodes and returns the next video frame.</summary>
            
             <p>The methods/functions combine "VideoCapture.grab" and "VideoCapture.retrieve"
             in one call. This is the most convenient method for reading video files or
             capturing data from decode and return the just grabbed frame. If no frames
             has been grabbed (camera has been disconnected, or there are no more frames
             in video file), the methods return false and the functions return NULL
             pointer.</p>
            
             <p>Note: OpenCV 1.x functions <code>cvRetrieveFrame</code> and <code>cv.RetrieveFrame</code>
             return image stored inside the video capturing structure. It is not allowed
             to modify or release the image! You can copy the frame using "cvCloneImage"
             and then do whatever you want with the copy.</p>
            
             <param>image a image</param>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-read">org.opencv.highgui.VideoCapture.read</a>
        </member>
        <member name="M:OpenCVUnity.VideoCapture.release">
             <summary>Closes video file or capturing device.</summary>
            
             <p>The methods are automatically called by subsequent "VideoCapture.open" and
             by <code>VideoCapture</code> destructor.</p>
            
             <p>The C function also deallocates memory and clears <code>*capture</code>
             pointer.</p>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-release">org.opencv.highgui.VideoCapture.release</a>
        </member>
        <member name="M:OpenCVUnity.VideoCapture.retrieve(OpenCVUnity.Mat,System.Int32)">
             <summary>Decodes and returns the grabbed video frame.</summary>
            
             <p>The methods/functions decode and return the just grabbed frame. If no frames
             has been grabbed (camera has been disconnected, or there are no more frames
             in video file), the methods return false and the functions return NULL
             pointer.</p>
            
             <p>Note: OpenCV 1.x functions <code>cvRetrieveFrame</code> and <code>cv.RetrieveFrame</code>
             return image stored inside the video capturing structure. It is not allowed
             to modify or release the image! You can copy the frame using "cvCloneImage"
             and then do whatever you want with the copy.</p>
            
             <param>image a image</param>
             <param>channel a channel</param>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-retrieve">org.opencv.highgui.VideoCapture.retrieve</a>
        </member>
        <member name="M:OpenCVUnity.VideoCapture.retrieve(OpenCVUnity.Mat)">
             <summary>Decodes and returns the grabbed video frame.</summary>
            
             <p>The methods/functions decode and return the just grabbed frame. If no frames
             has been grabbed (camera has been disconnected, or there are no more frames
             in video file), the methods return false and the functions return NULL
             pointer.</p>
            
             <p>Note: OpenCV 1.x functions <code>cvRetrieveFrame</code> and <code>cv.RetrieveFrame</code>
             return image stored inside the video capturing structure. It is not allowed
             to modify or release the image! You can copy the frame using "cvCloneImage"
             and then do whatever you want with the copy.</p>
            
             <param>image a image</param>
            
             <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-retrieve">org.opencv.highgui.VideoCapture.retrieve</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.VideoCapture.set(System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Canny(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Canny(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double)" -->
        <member name="M:OpenCVUnity.Imgproc.GaussianBlur(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Double,System.Double,System.Int32)">
             <summary>Blurs an image using a Gaussian filter.</summary>
            
             <p>The function convolves the source image with the specified Gaussian kernel.
             In-place filtering is supported.</p>
            
             <param>src input image; the image can have any number of channels, which are</param>
             processed independently, but the depth should be <code>CV_8U</code>,
             <code>CV_16U</code>, <code>CV_16S</code>, <code>CV_32F</code> or
             <code>CV_64F</code>.
             <param>dst output image of the same size and type as <code>src</code>.</param>
             <param>ksize Gaussian kernel size. <code>ksize.width</code> and</param>
             <code>ksize.height</code> can differ but they both must be positive and odd.
             Or, they can be zero's and then they are computed from <code>sigma*</code>.
             <param>sigmaX Gaussian kernel standard deviation in X direction.</param>
             <param>sigmaY Gaussian kernel standard deviation in Y direction; if</param>
             <code>sigmaY</code> is zero, it is set to be equal to <code>sigmaX</code>, if
             both sigmas are zeros, they are computed from <code>ksize.width</code> and
             <code>ksize.height</code>, respectively (see "getGaussianKernel" for
             details); to fully control the result regardless of possible future
             modifications of all this semantics, it is recommended to specify all of
             <code>ksize</code>, <code>sigmaX</code>, and <code>sigmaY</code>.
             <param>borderType pixel extrapolation method (see "borderInterpolate" for</param>
             details).
            
             <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur">org.opencv.imgproc.Imgproc.GaussianBlur</a>
             org.opencv.imgproc.Imgproc#sepFilter2D
             org.opencv.imgproc.Imgproc#medianBlur
             org.opencv.imgproc.Imgproc#boxFilter
             org.opencv.imgproc.Imgproc#blur
             org.opencv.imgproc.Imgproc#filter2D
             org.opencv.imgproc.Imgproc#bilateralFilter
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.GaussianBlur(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.GaussianBlur(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.HoughCircles(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.HoughCircles(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.HoughLines(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.HoughLines(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.HoughLinesP(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.HoughLinesP(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.HuMoments(OpenCVUnity.Moments,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Laplacian(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Laplacian(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Laplacian(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Scharr(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Scharr(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Scharr(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Sobel(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Sobel(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.Sobel(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulate(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulate(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulateProduct(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulateProduct(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulateSquare(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulateSquare(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulateWeighted(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.accumulateWeighted(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.adaptiveThreshold(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Int32,System.Int32,System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.approxPolyDP(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,System.Double,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.arcLength(OpenCVUnity.MatOfPoint2f,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.bilateralFilter(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.bilateralFilter(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.blur(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Point,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.blur(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Point)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.blur(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.boundingRect(OpenCVUnity.MatOfPoint)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.boxFilter(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Size,OpenCVUnity.Point,System.Boolean,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.boxFilter(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Size,OpenCVUnity.Point,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.boxFilter(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.calcBackProject(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.MatOfInt,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfFloat,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.calcHist(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.MatOfInt,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfInt,OpenCVUnity.MatOfFloat,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.calcHist(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.MatOfInt,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfInt,OpenCVUnity.MatOfFloat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.compareHist(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.contourArea(OpenCVUnity.Mat,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.contourArea(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.convertMaps(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.convertMaps(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.convexHull(OpenCVUnity.MatOfPoint,OpenCVUnity.MatOfInt,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.convexHull(OpenCVUnity.MatOfPoint,OpenCVUnity.MatOfInt)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.convexityDefects(OpenCVUnity.MatOfPoint,OpenCVUnity.MatOfInt,OpenCVUnity.MatOfInt4)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cornerEigenValsAndVecs(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cornerEigenValsAndVecs(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cornerHarris(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Double,System.Int32)" -->
        <member name="M:OpenCVUnity.Imgproc.cornerHarris(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Double)">
             <summary>Harris edge detector.</summary>
            
             <p>The function runs the Harris edge detector on the image. Similarly to
             "cornerMinEigenVal" and "cornerEigenValsAndVecs", for each pixel <em>(x,
             y)</em> it calculates a <em>2x2</em> gradient covariance matrix
             <em>M^((x,y))</em> over a <em>blockSize x blockSize</em> neighborhood. Then,
             it computes the following characteristic:</p>
            
             <p><em>dst(x,y) = det M^((x,y)) - k/// (tr M^((x,y)))^2</em></p>
            
             <p>Corners in the image can be found as the local maxima of this response map.</p>
            
             <param>src Input single-channel 8-bit or floating-point image.</param>
             <param>dst Image to store the Harris detector responses. It has the type</param>
             <code>CV_32FC1</code> and the same size as <code>src</code>.
             <param>blockSize Neighborhood size (see the details on "cornerEigenValsAndVecs").</param>
             <param>ksize Aperture parameter for the "Sobel" operator.</param>
             <param>k Harris detector free parameter. See the formula below.</param>
            
             <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornerharris">org.opencv.imgproc.Imgproc.cornerHarris</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cornerMinEigenVal(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cornerMinEigenVal(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cornerMinEigenVal(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <member name="M:OpenCVUnity.Imgproc.cornerSubPix(OpenCVUnity.Mat,OpenCVUnity.MatOfPoint2f,OpenCVUnity.Size,OpenCVUnity.Size,OpenCVUnity.TermCriteria)">
             <summary>Refines the corner locations.</summary>
            
             <p>The function iterates to find the sub-pixel accurate location of corners or
             radial saddle points, as shown on the figure below.</p>
            
             <p>Sub-pixel accurate corner locator is based on the observation that every
             vector from the center <em>q</em> to a point <em>p</em> located within a
             neighborhood of <em>q</em> is orthogonal to the image gradient at <em>p</em>
             subject to image and measurement noise. Consider the expression:</p>
            
             <p><em>epsilon _i = (DI_(p_i))^T/// (q - p_i)</em></p>
            
             <p>where <em>(DI_(p_i))</em> is an image gradient at one of the points
             <em>p_i</em> in a neighborhood of <em>q</em>. The value of <em>q</em> is to
             be found so that <em>epsilon_i</em> is minimized. A system of equations may
             be set up with <em>epsilon_i</em> set to zero:</p>
            
             <p><em>sum _i(DI_(p_i)/// (DI_(p_i))^T) - sum _i(DI_(p_i)/// (DI_(p_i))^T///
             p_i)</em></p>
            
             <p>where the gradients are summed within a neighborhood ("search window") of
             <em>q</em>. Calling the first gradient term <em>G</em> and the second
             gradient term <em>b</em> gives:</p>
            
             <p><em>q = G^(-1)/// b</em></p>
            
             <p>The algorithm sets the center of the neighborhood window at this new center
             <em>q</em> and then iterates until the center stays within a set threshold.</p>
            
             <param>image Input image.</param>
             <param>corners Initial coordinates of the input corners and refined</param>
             coordinates provided for output.
             <param>winSize Half of the side length of the search window. For example, if</param>
             <code>winSize=Size(5,5)</code>, then a <em>5*2+1 x 5*2+1 = 11 x 11</em>
             search window is used.
             <param>zeroZone Half of the size of the dead region in the middle of the</param>
             search zone over which the summation in the formula below is not done. It is
             used sometimes to avoid possible singularities of the autocorrelation matrix.
             The value of (-1,-1) indicates that there is no such a size.
             <param>criteria Criteria for termination of the iterative process of corner</param>
             refinement. That is, the process of corner position refinement stops either
             after <code>criteria.maxCount</code> iterations or when the corner position
             moves by less than <code>criteria.epsilon</code> on some iteration.
            
             <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornersubpix">org.opencv.imgproc.Imgproc.cornerSubPix</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.createHanningWindow(OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cvtColor(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.cvtColor(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.dilate(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32,System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.dilate(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.dilate(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.distanceTransform(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.distanceTransformWithLabels(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.distanceTransformWithLabels(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.drawContours(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},System.Int32,OpenCVUnity.Scalar,System.Int32,System.Int32,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Point)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.drawContours(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},System.Int32,OpenCVUnity.Scalar,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.drawContours(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.equalizeHist(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.erode(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32,System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.erode(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.erode(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.filter2D(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Point,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.filter2D(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Point,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.filter2D(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.findContours(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},OpenCVUnity.Mat,System.Int32,System.Int32,OpenCVUnity.Point)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.findContours(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.fitEllipse(OpenCVUnity.MatOfPoint2f)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.fitLine(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Double,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.floodFill(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Scalar,OpenCVUnity.Rect,OpenCVUnity.Scalar,OpenCVUnity.Scalar,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.floodFill(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getAffineTransform(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getDefaultNewCameraMatrix(OpenCVUnity.Mat,OpenCVUnity.Size,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getDefaultNewCameraMatrix(OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Imgproc.getDerivKernels(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32)">
             <summary>Returns filter coefficients for computing spatial image derivatives.</summary>
            
             <p>The function computes and returns the filter coefficients for spatial image
             derivatives. When <code>ksize=CV_SCHARR</code>, the Scharr <em>3 x 3</em>
             kernels are generated (see "Scharr"). Otherwise, Sobel kernels are generated
             (see "Sobel"). The filters are normally passed to "sepFilter2D" or to
             "createSeparableLinearFilter".</p>
            
             <param>kx Output matrix of row filter coefficients. It has the type</param>
             <code>ktype</code>.
             <param>ky Output matrix of column filter coefficients. It has the type</param>
             <code>ktype</code>.
             <param>dx Derivative order in respect of x.</param>
             <param>dy Derivative order in respect of y.</param>
             <param>ksize Aperture size. It can be <code>CV_SCHARR</code>, 1, 3, 5, or 7.</param>
             <param>normalize Flag indicating whether to normalize (scale down) the filter</param>
             coefficients or not. Theoretically, the coefficients should have the
             denominator <em>=2^(ksize*2-dx-dy-2)</em>. If you are going to filter
             floating-point images, you are likely to use the normalized kernels. But if
             you compute derivatives of an 8-bit image, store the results in a 16-bit
             image, and wish to preserve all the fractional bits, you may want to set
             <code>normalize=false</code>.
             <param>ktype Type of filter coefficients. It can be <code>CV_32f</code> or</param>
             <code>CV_64F</code>.
            
             <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#getderivkernels">org.opencv.imgproc.Imgproc.getDerivKernels</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getDerivKernels(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getGaussianKernel(System.Int32,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getGaussianKernel(System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getPerspectiveTransform(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getRectSubPix(OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Point,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getRectSubPix(OpenCVUnity.Mat,OpenCVUnity.Size,OpenCVUnity.Point,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getRotationMatrix2D(OpenCVUnity.Point,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getStructuringElement(System.Int32,OpenCVUnity.Size,OpenCVUnity.Point)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getStructuringElement(System.Int32,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.goodFeaturesToTrack(OpenCVUnity.Mat,OpenCVUnity.MatOfPoint,System.Int32,System.Double,System.Double,OpenCVUnity.Mat,System.Int32,System.Boolean,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.goodFeaturesToTrack(OpenCVUnity.Mat,OpenCVUnity.MatOfPoint,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.grabCut(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Rect,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.grabCut(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Rect,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.initUndistortRectifyMap(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.integral(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.integral(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.integral2(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.integral2(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.integral3(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.integral3(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.invertAffineTransform(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.isContourConvex(OpenCVUnity.MatOfPoint)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.matchShapes(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.matchTemplate(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.medianBlur(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.minAreaRect(OpenCVUnity.MatOfPoint2f)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.minEnclosingCircle(OpenCVUnity.MatOfPoint2f,OpenCVUnity.Point,System.Single[])" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.moments(OpenCVUnity.Mat,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.moments(OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.morphologyEx(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32,System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.morphologyEx(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.morphologyEx(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.phaseCorrelate(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.phaseCorrelate(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pointPolygonTest(OpenCVUnity.MatOfPoint2f,OpenCVUnity.Point,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.preCornerDetect(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.preCornerDetect(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrDown(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrDown(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrDown(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrMeanShiftFiltering(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32,OpenCVUnity.TermCriteria)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrMeanShiftFiltering(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrUp(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrUp(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.pyrUp(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.remap(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.remap(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.resize(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.resize(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.sepFilter2D(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.sepFilter2D(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Point,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.sepFilter2D(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Int32,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.threshold(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.undistort(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.undistort(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.undistortPoints(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.undistortPoints(OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Imgproc.warpAffine(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32,System.Int32,OpenCVUnity.Scalar)">
             <summary>Applies an affine transformation to an image.</summary>
            
             <p>The function <code>warpAffine</code> transforms the source image using the
             specified matrix:</p>
            
             <p><em>dst(x,y) = src(M _11 x + M _12 y + M _13, M _21 x + M _22 y + M _23)</em></p>
            
             <p>when the flag <code>WARP_INVERSE_MAP</code> is set. Otherwise, the
             transformation is first inverted with "invertAffineTransform" and then put in
             the formula above instead of <code>M</code>.
             The function cannot operate in-place.</p>
            
             <p>Note: <code>cvGetQuadrangleSubPix</code> is similar to <code>cvWarpAffine</code>,
             but the outliers are extrapolated using replication border mode.</p>
            
             <param>src input image.</param>
             <param>dst output image that has the size <code>dsize</code> and the same</param>
             type as <code>src</code>.
             <param>M <em>2x 3</em> transformation matrix.</param>
             <param>dsize size of the output image.</param>
             <param>flags combination of interpolation methods (see "resize") and the</param>
             optional flag <code>WARP_INVERSE_MAP</code> that means that <code>M</code> is
             the inverse transformation (<em>dst->src</em>).
             <param>borderMode pixel extrapolation method (see "borderInterpolate"); when</param>
             <code>borderMode=BORDER_TRANSPARENT</code>, it means that the pixels in the
             destination image corresponding to the "outliers" in the source image are not
             modified by the function.
             <param>borderValue value used in case of a constant border; by default, it is</param>
             0.
            
             <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpaffine">org.opencv.imgproc.Imgproc.warpAffine</a>
             org.opencv.imgproc.Imgproc#remap
             org.opencv.imgproc.Imgproc#warpPerspective
             org.opencv.imgproc.Imgproc#getRectSubPix
             org.opencv.imgproc.Imgproc#resize
             org.opencv.core.Core#transform
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.warpAffine(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.warpAffine(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.warpPerspective(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32,System.Int32,OpenCVUnity.Scalar)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.warpPerspective(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.warpPerspective(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Size)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.watershed(OpenCVUnity.Mat,OpenCVUnity.Mat)" -->
        <member name="M:OpenCVUnity.Imgproc.rectangle(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar,System.Int32,System.Int32,System.Int32)">
             <summary>Draws a simple, thick, or filled up-right rectangle.</summary>
            
             <p>The function <code>rectangle</code> draws a rectangle outline or a filled
             rectangle whose two opposite corners are <code>pt1</code> and
             <code>pt2</code>, or <code>r.tl()</code> and <code>r.br()-Point(1,1)</code>.</p>
            
             <param>img Image.</param>
             <param>pt1 Vertex of the rectangle.</param>
             <param>pt2 Vertex of the rectangle opposite to <code>pt1</code>.</param>
             <param>color Rectangle color or brightness (grayscale image).</param>
             <param>thickness Thickness of lines that make up the rectangle. Negative</param>
             values, like <code>CV_FILLED</code>, mean that the function has to draw a
             filled rectangle.
             <param>lineType Type of the line. See the "line" description.</param>
             <param>shift Number of fractional bits in the point coordinates.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle">org.opencv.core.Core.rectangle</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.rectangle(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws a simple, thick, or filled up-right rectangle.</summary>
            
             <p>The function <code>rectangle</code> draws a rectangle outline or a filled
             rectangle whose two opposite corners are <code>pt1</code> and
             <code>pt2</code>, or <code>r.tl()</code> and <code>r.br()-Point(1,1)</code>.</p>
            
             <param>img Image.</param>
             <param>pt1 Vertex of the rectangle.</param>
             <param>pt2 Vertex of the rectangle opposite to <code>pt1</code>.</param>
             <param>color Rectangle color or brightness (grayscale image).</param>
             <param>thickness Thickness of lines that make up the rectangle. Negative
             values, like <code>CV_FILLED</code>, mean that the function has to draw a
             filled rectangle.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle">org.opencv.core.Core.rectangle</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.rectangle(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar)">
             <summary>Draws a simple, thick, or filled up-right rectangle.</summary>
            
             <p>The function <code>rectangle</code> draws a rectangle outline or a filled
             rectangle whose two opposite corners are <code>pt1</code> and
             <code>pt2</code>, or <code>r.tl()</code> and <code>r.br()-Point(1,1)</code>.</p>
            
             <param>img Image.</param>
             <param>pt1 Vertex of the rectangle.</param>
             <param>pt2 Vertex of the rectangle opposite to <code>pt1</code>.</param>
             <param>color Rectangle color or brightness (grayscale image).</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle">org.opencv.core.Core.rectangle</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.putText(OpenCVUnity.Mat,System.String,OpenCVUnity.Point,System.Int32,System.Double,OpenCVUnity.Scalar,System.Int32,System.Int32,System.Boolean)">
             <summary>Draws a text string.</summary>
            
             <p>The function <code>putText</code> renders the specified text string in the
             image.
             Symbols that cannot be rendered using the specified font are replaced by
             question marks. See "getTextSize" for a text rendering code example.</p>
            
             <param>img Image.</param>
             <param>text Text string to be drawn.</param>
             <param>org Bottom-left corner of the text string in the image.</param>
             <param>fontFace Font type. One of <code>FONT_HERSHEY_SIMPLEX</code>,
             <code>FONT_HERSHEY_PLAIN</code>, <code>FONT_HERSHEY_DUPLEX</code>,
             <code>FONT_HERSHEY_COMPLEX</code>, <code>FONT_HERSHEY_TRIPLEX</code>,
             <code>FONT_HERSHEY_COMPLEX_SMALL</code>, <code>FONT_HERSHEY_SCRIPT_SIMPLEX</code>,
             or <code>FONT_HERSHEY_SCRIPT_COMPLEX</code>, where each of the font ID's can
             be combined with <code>FONT_ITALIC</code> to get the slanted letters.</param>
             <param>fontScale Font scale factor that is multiplied by the font-specific
             base size.</param>
             <param>color Text color.</param>
             <param>thickness Thickness of the lines used to draw a text.</param>
             <param>lineType Line type. See the <code>line</code> for details.</param>
             <param>bottomLeftOrigin When true, the image data origin is at the
             bottom-left corner. Otherwise, it is at the top-left corner.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext">org.opencv.core.Core.putText</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.putText(OpenCVUnity.Mat,System.String,OpenCVUnity.Point,System.Int32,System.Double,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws a text string.</summary>
            
             <p>The function <code>putText</code> renders the specified text string in the
             image.
             Symbols that cannot be rendered using the specified font are replaced by
             question marks. See "getTextSize" for a text rendering code example.</p>
            
             <param>img Image.</param>
             <param>text Text string to be drawn.</param>
             <param>org Bottom-left corner of the text string in the image.</param>
             <param>fontFace Font type. One of <code>FONT_HERSHEY_SIMPLEX</code>,
             <code>FONT_HERSHEY_PLAIN</code>, <code>FONT_HERSHEY_DUPLEX</code>,
             <code>FONT_HERSHEY_COMPLEX</code>, <code>FONT_HERSHEY_TRIPLEX</code>,
             <code>FONT_HERSHEY_COMPLEX_SMALL</code>, <code>FONT_HERSHEY_SCRIPT_SIMPLEX</code>,
             or <code>FONT_HERSHEY_SCRIPT_COMPLEX</code>, where each of the font ID's can
             be combined with <code>FONT_ITALIC</code> to get the slanted letters.</param>
             <param>fontScale Font scale factor that is multiplied by the font-specific
             base size.</param>
             <param>color Text color.</param>
             <param>thickness Thickness of the lines used to draw a text.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext">org.opencv.core.Core.putText</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.putText(OpenCVUnity.Mat,System.String,OpenCVUnity.Point,System.Int32,System.Double,OpenCVUnity.Scalar)">
             <summary>Draws a text string.</summary>
            
             <p>The function <code>putText</code> renders the specified text string in the
             image.
             Symbols that cannot be rendered using the specified font are replaced by
             question marks. See "getTextSize" for a text rendering code example.</p>
            
             <param>img Image.</param>
             <param>text Text string to be drawn.</param>
             <param>org Bottom-left corner of the text string in the image.</param>
             <param>fontFace Font type. One of <code>FONT_HERSHEY_SIMPLEX</code>,
             <code>FONT_HERSHEY_PLAIN</code>, <code>FONT_HERSHEY_DUPLEX</code>,
             <code>FONT_HERSHEY_COMPLEX</code>, <code>FONT_HERSHEY_TRIPLEX</code>,
             <code>FONT_HERSHEY_COMPLEX_SMALL</code>, <code>FONT_HERSHEY_SCRIPT_SIMPLEX</code>,
             or <code>FONT_HERSHEY_SCRIPT_COMPLEX</code>, where each of the font ID's can
             be combined with <code>FONT_ITALIC</code> to get the slanted letters.</param>
             <param>fontScale Font scale factor that is multiplied by the font-specific
             base size.</param>
             <param>color Text color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext">org.opencv.core.Core.putText</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.polylines(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},System.Boolean,OpenCVUnity.Scalar,System.Int32,System.Int32,System.Int32)">
             <summary>Draws several polygonal curves.</summary>
            
             <p>The function <code>polylines</code> draws one or more polygonal curves.</p>
            
             <param>img Image.</param>
             <param>pts Array of polygonal curves.</param>
             <param>isClosed Flag indicating whether the drawn polylines are closed or
             not. If they are closed, the function draws a line from the last vertex of
             each curve to its first vertex.</param>
             <param>color Polyline color.</param>
             <param>thickness Thickness of the polyline edges.</param>
             <param>lineType Type of the line segments. See the "line" description.</param>
             <param>shift Number of fractional bits in the vertex coordinates.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines">org.opencv.core.Core.polylines</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.polylines(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},System.Boolean,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws several polygonal curves.</summary>
            
             <p>The function <code>polylines</code> draws one or more polygonal curves.</p>
            
             <param>img Image.</param>
             <param>pts Array of polygonal curves.</param>
             <param>isClosed Flag indicating whether the drawn polylines are closed or
             not. If they are closed, the function draws a line from the last vertex of
             each curve to its first vertex.</param>
             <param>color Polyline color.</param>
             <param>thickness Thickness of the polyline edges.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines">org.opencv.core.Core.polylines</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.polylines(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},System.Boolean,OpenCVUnity.Scalar)">
             <summary>Draws several polygonal curves.</summary>
            
             <p>The function <code>polylines</code> draws one or more polygonal curves.</p>
            
             <param>img Image.</param>
             <param>pts Array of polygonal curves.</param>
             <param>isClosed Flag indicating whether the drawn polylines are closed or
             not. If they are closed, the function draws a line from the last vertex of
             each curve to its first vertex.</param>
             <param>color Polyline color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines">org.opencv.core.Core.polylines</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.line(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:OpenCVUnity.Imgproc.line(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws a line segment connecting two points.</summary>
            
             <p>The function <code>line</code> draws the line segment between
             <code>pt1</code> and <code>pt2</code> points in the image. The line is
             clipped by the image boundaries. For non-antialiased lines with integer
             coordinates, the 8-connected or 4-connected Bresenham algorithm is used.
             Thick lines are drawn with rounding endings.
             Antialiased lines are drawn using Gaussian filtering. To specify the line
             color, you may use the macro <code>CV_RGB(r, g, b)</code>.</p>
            
             <param>img Image.</param>
             <param>pt1 First point of the line segment.</param>
             <param>pt2 Second point of the line segment.</param>
             <param>color Line color.</param>
             <param>thickness Line thickness.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#line">org.opencv.core.Core.line</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.line(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar)">
             <summary>Draws a line segment connecting two points.</summary>
            
             <p>The function <code>line</code> draws the line segment between
             <code>pt1</code> and <code>pt2</code> points in the image. The line is
             clipped by the image boundaries. For non-antialiased lines with integer
             coordinates, the 8-connected or 4-connected Bresenham algorithm is used.
             Thick lines are drawn with rounding endings.
             Antialiased lines are drawn using Gaussian filtering. To specify the line
             color, you may use the macro <code>CV_RGB(r, g, b)</code>.</p>
            
             <param>img Image.</param>
             <param>pt1 First point of the line segment.</param>
             <param>pt2 Second point of the line segment.</param>
             <param>color Line color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#line">org.opencv.core.Core.line</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.fillConvexPoly(OpenCVUnity.Mat,OpenCVUnity.MatOfPoint,OpenCVUnity.Scalar,System.Int32,System.Int32)">
             <summary>Fills a convex polygon.</summary>
            
             <p>The function <code>fillConvexPoly</code> draws a filled convex polygon.
             This function is much faster than the function <code>fillPoly</code>. It can
             fill not only convex polygons but any monotonic polygon without
             self-intersections, that is, a polygon whose contour intersects every
             horizontal line (scan line) twice at the most (though, its top-most and/or
             the bottom edge could be horizontal).</p>
            
             <param>img Image.</param>
             <param>points a points</param>
             <param>color Polygon color.</param>
             <param>lineType Type of the polygon boundaries. See the "line" description.</param>
             <param>shift Number of fractional bits in the vertex coordinates.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillconvexpoly">org.opencv.core.Core.fillConvexPoly</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.fillConvexPoly(OpenCVUnity.Mat,OpenCVUnity.MatOfPoint,OpenCVUnity.Scalar)">
             <summary>Fills a convex polygon.</summary>
            
             <p>The function <code>fillConvexPoly</code> draws a filled convex polygon.
             This function is much faster than the function <code>fillPoly</code>. It can
             fill not only convex polygons but any monotonic polygon without
             self-intersections, that is, a polygon whose contour intersects every
             horizontal line (scan line) twice at the most (though, its top-most and/or
             the bottom edge could be horizontal).</p>
            
             <param>img Image.</param>
             <param>points a points</param>
             <param>color Polygon color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillconvexpoly">org.opencv.core.Core.fillConvexPoly</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.fillPoly(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},OpenCVUnity.Scalar,System.Int32,System.Int32,OpenCVUnity.Point)">
             <summary>Fills the area bounded by one or more polygons.</summary>
            
             <p>The function <code>fillPoly</code> fills an area bounded by several polygonal
             contours. The function can fill complex areas, for example, areas with holes,
             contours with self-intersections (some of their parts), and so forth.</p>
            
             <param>img Image.</param>
             <param>pts Array of polygons where each polygon is represented as an array of
             points.</param>
             <param>color Polygon color.</param>
             <param>lineType Type of the polygon boundaries. See the "line" description.</param>
             <param>shift Number of fractional bits in the vertex coordinates.</param>
             <param>offset Optional offset of all points of the contours.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillpoly">org.opencv.core.Core.fillPoly</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.ellipse(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Size,System.Double,System.Double,System.Double,OpenCVUnity.Scalar,System.Int32,System.Int32,System.Int32)">
             <summary>Draws a simple or thick elliptic arc or fills an ellipse sector.</summary>
            
             <p>The functions <code>ellipse</code> with less parameters draw an ellipse
             outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
             A piecewise-linear curve is used to approximate the elliptic arc boundary. If
             you need more control of the ellipse rendering, you can retrieve the curve
             using "ellipse2Poly" and then render it with "polylines" or fill it with
             "fillPoly". If you use the first variant of the function and want to draw the
             whole ellipse, not an arc, pass <code>startAngle=0</code> and
             <code>endAngle=360</code>. The figure below explains the meaning of the
             parameters.
             Figure 1. Parameters of Elliptic Arc</p>
            
             <param>img Image.</param>
             <param>center Center of the ellipse.</param>
             <param>axes Half of the size of the ellipse main axes.</param>
             <param>angle Ellipse rotation angle in degrees.</param>
             <param>startAngle Starting angle of the elliptic arc in degrees.</param>
             <param>endAngle Ending angle of the elliptic arc in degrees.</param>
             <param>color Ellipse color.</param>
             <param>thickness Thickness of the ellipse arc outline, if positive.
             Otherwise, this indicates that a filled ellipse sector is to be drawn.</param>
             <param>lineType Type of the ellipse boundary. See the "line" description.</param>
             <param>shift Number of fractional bits in the coordinates of the center and
             values of axes.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.ellipse(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Size,System.Double,System.Double,System.Double,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws a simple or thick elliptic arc or fills an ellipse sector.</summary>
            
             <p>The functions <code>ellipse</code> with less parameters draw an ellipse
             outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
             A piecewise-linear curve is used to approximate the elliptic arc boundary. If
             you need more control of the ellipse rendering, you can retrieve the curve
             using "ellipse2Poly" and then render it with "polylines" or fill it with
             "fillPoly". If you use the first variant of the function and want to draw the
             whole ellipse, not an arc, pass <code>startAngle=0</code> and
             <code>endAngle=360</code>. The figure below explains the meaning of the
             parameters.
             Figure 1. Parameters of Elliptic Arc</p>
            
             <param>img Image.</param>
             <param>center Center of the ellipse.</param>
             <param>axes Half of the size of the ellipse main axes.</param>
             <param>angle Ellipse rotation angle in degrees.</param>
             <param>startAngle Starting angle of the elliptic arc in degrees.</param>
             <param>endAngle Ending angle of the elliptic arc in degrees.</param>
             <param>color Ellipse color.</param>
             <param>thickness Thickness of the ellipse arc outline, if positive.
             Otherwise, this indicates that a filled ellipse sector is to be drawn.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.ellipse(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Size,System.Double,System.Double,System.Double,OpenCVUnity.Scalar)">
             <summary>Draws a simple or thick elliptic arc or fills an ellipse sector.</summary>
            
             <p>The functions <code>ellipse</code> with less parameters draw an ellipse
             outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
             A piecewise-linear curve is used to approximate the elliptic arc boundary. If
             you need more control of the ellipse rendering, you can retrieve the curve
             using "ellipse2Poly" and then render it with "polylines" or fill it with
             "fillPoly". If you use the first variant of the function and want to draw the
             whole ellipse, not an arc, pass <code>startAngle=0</code> and
             <code>endAngle=360</code>. The figure below explains the meaning of the
             parameters.
             Figure 1. Parameters of Elliptic Arc</p>
            
             <param>img Image.</param>
             <param>center Center of the ellipse.</param>
             <param>axes Half of the size of the ellipse main axes.</param>
             <param>angle Ellipse rotation angle in degrees.</param>
             <param>startAngle Starting angle of the elliptic arc in degrees.</param>
             <param>endAngle Ending angle of the elliptic arc in degrees.</param>
             <param>color Ellipse color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.ellipse(OpenCVUnity.Mat,OpenCVUnity.RotatedRect,OpenCVUnity.Scalar,System.Int32,System.Int32)">
             <summary>Draws a simple or thick elliptic arc or fills an ellipse sector.</summary>
            
             <p>The functions <code>ellipse</code> with less parameters draw an ellipse
             outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
             A piecewise-linear curve is used to approximate the elliptic arc boundary. If
             you need more control of the ellipse rendering, you can retrieve the curve
             using "ellipse2Poly" and then render it with "polylines" or fill it with
             "fillPoly". If you use the first variant of the function and want to draw the
             whole ellipse, not an arc, pass <code>startAngle=0</code> and
             <code>endAngle=360</code>. The figure below explains the meaning of the
             parameters.
             Figure 1. Parameters of Elliptic Arc</p>
            
             <param>img Image.</param>
             <param>box Alternative ellipse representation via "RotatedRect" or
             <code>CvBox2D</code>. This means that the function draws an ellipse inscribed
             in the rotated rectangle.</param>
             <param>color Ellipse color.</param>
             <param>thickness Thickness of the ellipse arc outline, if positive.
             Otherwise, this indicates that a filled ellipse sector is to be drawn.</param>
             <param>lineType Type of the ellipse boundary. See the "line" description.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.ellipse(OpenCVUnity.Mat,OpenCVUnity.RotatedRect,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws a simple or thick elliptic arc or fills an ellipse sector.</summary>
            
             <p>The functions <code>ellipse</code> with less parameters draw an ellipse
             outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
             A piecewise-linear curve is used to approximate the elliptic arc boundary. If
             you need more control of the ellipse rendering, you can retrieve the curve
             using "ellipse2Poly" and then render it with "polylines" or fill it with
             "fillPoly". If you use the first variant of the function and want to draw the
             whole ellipse, not an arc, pass <code>startAngle=0</code> and
             <code>endAngle=360</code>. The figure below explains the meaning of the
             parameters.
             Figure 1. Parameters of Elliptic Arc</p>
            
             <param>img Image.</param>
             <param>box Alternative ellipse representation via "RotatedRect" or
             <code>CvBox2D</code>. This means that the function draws an ellipse inscribed
             in the rotated rectangle.</param>
             <param>color Ellipse color.</param>
             <param>thickness Thickness of the ellipse arc outline, if positive.
             Otherwise, this indicates that a filled ellipse sector is to be drawn.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.ellipse(OpenCVUnity.Mat,OpenCVUnity.RotatedRect,OpenCVUnity.Scalar)">
             <summary>Draws a simple or thick elliptic arc or fills an ellipse sector.</summary>
            
             <p>The functions <code>ellipse</code> with less parameters draw an ellipse
             outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
             A piecewise-linear curve is used to approximate the elliptic arc boundary. If
             you need more control of the ellipse rendering, you can retrieve the curve
             using "ellipse2Poly" and then render it with "polylines" or fill it with
             "fillPoly". If you use the first variant of the function and want to draw the
             whole ellipse, not an arc, pass <code>startAngle=0</code> and
             <code>endAngle=360</code>. The figure below explains the meaning of the
             parameters.
             Figure 1. Parameters of Elliptic Arc</p>
            
             <param>img Image.</param>
             <param>box Alternative ellipse representation via "RotatedRect" or
             <code>CvBox2D</code>. This means that the function draws an ellipse inscribed
             in the rotated rectangle.</param>
             <param>color Ellipse color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.ellipse2Poly(OpenCVUnity.Point,OpenCVUnity.Size,System.Int32,System.Int32,System.Int32,System.Int32,OpenCVUnity.MatOfPoint)">
             <summary>Approximates an elliptic arc with a polyline.</summary>
            
             <p>The function <code>ellipse2Poly</code> computes the vertices of a polyline
             that approximates the specified elliptic arc. It is used by "ellipse".</p>
            
             <param>center Center of the arc.</param>
             <param>axes Half of the size of the ellipse main axes. See the "ellipse" for
             details.</param>
             <param>angle Rotation angle of the ellipse in degrees. See the "ellipse" for
             details.</param>
             <param>arcStart Starting angle of the elliptic arc in degrees.</param>
             <param>arcEnd Ending angle of the elliptic arc in degrees.</param>
             <param>delta Angle between the subsequent polyline vertices. It defines the
             approximation accuracy.</param>
             <param>pts Output vector of polyline vertices.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse2poly">org.opencv.core.Core.ellipse2Poly</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.fillPoly(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.MatOfPoint},OpenCVUnity.Scalar)">
             <summary>Fills the area bounded by one or more polygons.</summary>
            
             <p>The function <code>fillPoly</code> fills an area bounded by several polygonal
             contours. The function can fill complex areas, for example, areas with holes,
             contours with self-intersections (some of their parts), and so forth.</p>
            
             <param>img Image.</param>
             <param>pts Array of polygons where each polygon is represented as an array of
             points.</param>
             <param>color Polygon color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillpoly">org.opencv.core.Core.fillPoly</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.circle(OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32,OpenCVUnity.Scalar,System.Int32,System.Int32,System.Int32)">
             <summary>Draws a circle.</summary>
            
             <p>The function <code>circle</code> draws a simple or filled circle with a given
             center and radius.</p>
            
             <param>img Image where the circle is drawn.</param>
             <param>center Center of the circle.</param>
             <param>radius Radius of the circle.</param>
             <param>color Circle color.</param>
             <param>thickness Thickness of the circle outline, if positive. Negative
             thickness means that a filled circle is to be drawn.</param>
             <param>lineType Type of the circle boundary. See the "line" description.</param>
             <param>shift Number of fractional bits in the coordinates of the center and
             in the radius value.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle">org.opencv.core.Core.circle</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.circle(OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32,OpenCVUnity.Scalar,System.Int32)">
             <summary>Draws a circle.</summary>
            
             <p>The function <code>circle</code> draws a simple or filled circle with a given
             center and radius.</p>
            
             <param>img Image where the circle is drawn.</param>
             <param>center Center of the circle.</param>
             <param>radius Radius of the circle.</param>
             <param>color Circle color.</param>
             <param>thickness Thickness of the circle outline, if positive. Negative
             thickness means that a filled circle is to be drawn.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle">org.opencv.core.Core.circle</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.circle(OpenCVUnity.Mat,OpenCVUnity.Point,System.Int32,OpenCVUnity.Scalar)">
             <summary>Draws a circle.</summary>
            
             <p>The function <code>circle</code> draws a simple or filled circle with a given
             center and radius.</p>
            
             <param>img Image where the circle is drawn.</param>
             <param>center Center of the circle.</param>
             <param>radius Radius of the circle.</param>
             <param>color Circle color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle">org.opencv.core.Core.circle</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.arrowedLine(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar,System.Int32,System.Int32,System.Int32,System.Double)">
             <summary>Draws a arrow segment pointing from the first point to the second one.</summary>
            
             <p>The function <code>arrowedLine</code> draws an arrow between <code>pt1</code>
             and <code>pt2</code> points in the image. See also "line".</p>
            
             <param>img Image.</param>
             <param>pt1 The point the arrow starts from.</param>
             <param>pt2 The point the arrow points to.</param>
             <param>color Line color.</param>
             <param>thickness Line thickness.</param>
             <param>line_type a line_type</param>
             <param>shift Number of fractional bits in the point coordinates.</param>
             <param>tipLength The length of the arrow tip in relation to the arrow length</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#arrowedline">org.opencv.core.Core.arrowedLine</a>
        </member>
        <member name="M:OpenCVUnity.Imgproc.arrowedLine(OpenCVUnity.Mat,OpenCVUnity.Point,OpenCVUnity.Point,OpenCVUnity.Scalar)">
             <summary>Draws a arrow segment pointing from the first point to the second one.</summary>
            
             <p>The function <code>arrowedLine</code> draws an arrow between <code>pt1</code>
             and <code>pt2</code> points in the image. See also "line".</p>
            
             <param>img Image.</param>
             <param>pt1 The point the arrow starts from.</param>
             <param>pt2 The point the arrow points to.</param>
             <param>color Line color.</param>
            
             <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#arrowedline">org.opencv.core.Core.arrowedLine</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Imgproc.getTextSize(System.String,System.Int32,System.Double,System.Int32,System.Int32[])" -->
        <member name="T:OpenCVUnity.CvANN_MLP">
             <summary>MLP model.</summary>
            
             <p>Unlike many other models in ML that are constructed and trained at once, in
             the MLP model these steps are separated. First, a network with the specified
             topology is created using the non-default constructor or the method
             "CvANN_MLP.create". All the weights are set to zeros. Then, the network is
             trained using a set of input and output vectors. The training procedure can
             be repeated more than once, that is, the weights can be adjusted based on the
             new training data.</p>
            
             <a href="http://docs.opencv.org/modules/ml/doc/neural_networks.html#cvann-mlp">org.opencv.ml.CvANN_MLP : public CvStatModel</a>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvANN_MLP_TrainParams" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.CvANN_MLP_TrainParams.#ctor" -->
        <member name="T:OpenCVUnity.CvBoost">
             <summary>Boosted tree classifier derived from "CvStatModel".</summary>
            
             <a href="http://docs.opencv.org/modules/ml/doc/boosting.html#cvboost">org.opencv.ml.CvBoost : public CvStatModel</a>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvBoostParams" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvDTree" -->
        <member name="T:OpenCVUnity.CvDTreeParams">
             <summary>The structure contains all the decision tree training parameters. You can
             initialize it by default constructor and then override any parameters
             directly before training, or the structure may be fully initialized using the
             advanced variant of the constructor.</summary>
            
             <a href="http://docs.opencv.org/modules/ml/doc/decision_trees.html#cvdtreeparams">org.opencv.ml.CvDTreeParams</a>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvKNearest" -->
        <member name="T:OpenCVUnity.CvNormalBayesClassifier">
             <summary>Bayes classifier for normally distributed data.</summary>
            
             <a href="http://docs.opencv.org/modules/ml/doc/normal_bayes_classifier.html#cvnormalbayesclassifier">org.opencv.ml.CvNormalBayesClassifier : public CvStatModel</a>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvParamGrid" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.CvParamGrid.#ctor" -->
        <member name="T:OpenCVUnity.CvRTParams">
             <summary>Training parameters of random trees.</summary>
            
             <p>The set of training parameters for the forest is a superset of the training
             parameters for a single tree. However, random trees do not need all the
             functionality/features of decision trees. Most noticeably, the trees are not
             pruned, so the cross-validation parameters are not used.</p>
            
             <a href="http://docs.opencv.org/modules/ml/doc/random_trees.html#cvrtparams">org.opencv.ml.CvRTParams : public CvDTreeParams</a>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvRTrees" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvStatModel" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.CvSVM" -->
        <member name="T:OpenCVUnity.CvSVMParams">
             <summary>SVM training parameters.</summary>
            
             <p>The structure must be initialized and passed to the training method of
             "CvSVM".</p>
            
             <a href="http://docs.opencv.org/modules/ml/doc/support_vector_machines.html#cvsvmparams">org.opencv.ml.CvSVMParams</a>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.EM" -->
        <member name="T:OpenCVUnity.CascadeClassifier">
             <summary>Cascade classifier class for object detection.</summary>
            
             <a href="http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html#cascadeclassifier">org.opencv.objdetect.CascadeClassifier</a>
        </member>
        <member name="M:OpenCVUnity.Objdetect.groupRectangles(OpenCVUnity.MatOfRect,OpenCVUnity.MatOfInt,System.Int32,System.Double)">
             <summary>Groups the object candidate rectangles.</summary>
            
             <p>The function is a wrapper for the generic function "partition". It clusters
             all the input rectangles using the rectangle equivalence criteria that
             combines rectangles with similar sizes and similar locations. The similarity
             is defined by <code>eps</code>. When <code>eps=0</code>, no clustering is
             done at all. If <em>eps-> +inf</em>, all the rectangles are put in one
             cluster. Then, the small clusters containing less than or equal to
             <code>groupThreshold</code> rectangles are rejected. In each other cluster,
             the average rectangle is computed and put into the output rectangle list.</p>
            
             <param>rectList Input/output vector of rectangles. Output vector includes
             retained and grouped rectangles. (The Python list is not modified in place.)</param>
             <param>weights a weights</param>
             <param>groupThreshold Minimum possible number of rectangles minus 1. The
             threshold is used in a group of rectangles to retain it.</param>
             <param>eps Relative difference between sides of the rectangles to merge them
             into a group.</param>
            
             <a href="http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html#grouprectangles">org.opencv.objdetect.Objdetect.groupRectangles</a>
        </member>
        <member name="M:OpenCVUnity.Objdetect.groupRectangles(OpenCVUnity.MatOfRect,OpenCVUnity.MatOfInt,System.Int32)">
             <summary>Groups the object candidate rectangles.</summary>
            
             <p>The function is a wrapper for the generic function "partition". It clusters
             all the input rectangles using the rectangle equivalence criteria that
             combines rectangles with similar sizes and similar locations. The similarity
             is defined by <code>eps</code>. When <code>eps=0</code>, no clustering is
             done at all. If <em>eps-> +inf</em>, all the rectangles are put in one
             cluster. Then, the small clusters containing less than or equal to
             <code>groupThreshold</code> rectangles are rejected. In each other cluster,
             the average rectangle is computed and put into the output rectangle list.</p>
            
             <param>rectList Input/output vector of rectangles. Output vector includes
             retained and grouped rectangles. (The Python list is not modified in place.)</param>
             <param>weights a weights</param>
             <param>groupThreshold Minimum possible number of rectangles minus 1. The
             threshold is used in a group of rectangles to retain it.</param>
            
             <a href="http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html#grouprectangles">org.opencv.objdetect.Objdetect.groupRectangles</a>
        </member>
        <member name="M:OpenCVUnity.Photo.fastNlMeansDenoising(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Single,System.Int32,System.Int32)">
             <summary>Perform image denoising using Non-local Means Denoising algorithm
             http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ with several
             computational optimizations. Noise expected to be a gaussian white noise</summary>
            
             <p>This function expected to be applied to grayscale images. For colored images
             look at <code>fastNlMeansDenoisingColored</code>.
             Advanced usage of this functions can be manual denoising of colored image in
             different colorspaces.
             Such approach is used in <code>fastNlMeansDenoisingColored</code> by
             converting image to CIELAB colorspace and then separately denoise L and AB
             components with different h parameter.</p>
            
             <param>src Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
             <param>dst Output image with the same size and type as <code>src</code>.</param>
             <param>h Parameter regulating filter strength. Big h value perfectly removes
             noise but also removes image details, smaller h value preserves details but
             also preserves some noise</param>
             <param>templateWindowSize Size in pixels of the template patch that is used
             to compute weights. Should be odd. Recommended value 7 pixels</param>
             <param>searchWindowSize Size in pixels of the window that is used to compute
             weighted average for given pixel. Should be odd. Affect performance linearly:
             greater searchWindowsSize - greater denoising time. Recommended value 21
             pixels</param>
            
             <a href="http://docs.opencv.org/modules/photo/doc/denoising.html#fastnlmeansdenoising">org.opencv.photo.Photo.fastNlMeansDenoising</a>
        </member>
        <member name="M:OpenCVUnity.Photo.fastNlMeansDenoising(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Perform image denoising using Non-local Means Denoising algorithm
             http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ with several
             computational optimizations. Noise expected to be a gaussian white noise</summary>
            
             <p>This function expected to be applied to grayscale images. For colored images
             look at <code>fastNlMeansDenoisingColored</code>.
             Advanced usage of this functions can be manual denoising of colored image in
             different colorspaces.
             Such approach is used in <code>fastNlMeansDenoisingColored</code> by
             converting image to CIELAB colorspace and then separately denoise L and AB
             components with different h parameter.</p>
            
             <param>src Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
             <param>dst Output image with the same size and type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/photo/doc/denoising.html#fastnlmeansdenoising">org.opencv.photo.Photo.fastNlMeansDenoising</a>
        </member>
        <member name="M:OpenCVUnity.Photo.fastNlMeansDenoisingColored(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Single,System.Single,System.Int32,System.Int32)">
             <summary>Modification of <code>fastNlMeansDenoising</code> function for colored images</summary>
            
             <p>The function converts image to CIELAB colorspace and then separately denoise
             L and AB components with given h parameters using <code>fastNlMeansDenoising</code>
             function.</p>
            
             <param>src Input 8-bit 3-channel image.</param>
             <param>dst Output image with the same size and type as <code>src</code>.</param>
             <param>h Parameter regulating filter strength for luminance component. Bigger
             h value perfectly removes noise but also removes image details, smaller h
             value preserves details but also preserves some noise</param>
             <param>hColor a hColor</param>
             <param>templateWindowSize Size in pixels of the template patch that is used
             to compute weights. Should be odd. Recommended value 7 pixels</param>
             <param>searchWindowSize Size in pixels of the window that is used to compute
             weighted average for given pixel. Should be odd. Affect performance linearly:
             greater searchWindowsSize - greater denoising time. Recommended value 21
             pixels</param>
            
             <a href="http://docs.opencv.org/modules/photo/doc/denoising.html#fastnlmeansdenoisingcolored">org.opencv.photo.Photo.fastNlMeansDenoisingColored</a>
        </member>
        <member name="M:OpenCVUnity.Photo.fastNlMeansDenoisingColored(OpenCVUnity.Mat,OpenCVUnity.Mat)">
             <summary>Modification of <code>fastNlMeansDenoising</code> function for colored images</summary>
            
             <p>The function converts image to CIELAB colorspace and then separately denoise
             L and AB components with given h parameters using <code>fastNlMeansDenoising</code>
             function.</p>
            
             <param>src Input 8-bit 3-channel image.</param>
             <param>dst Output image with the same size and type as <code>src</code>.</param>
            
             <a href="http://docs.opencv.org/modules/photo/doc/denoising.html#fastnlmeansdenoisingcolored">org.opencv.photo.Photo.fastNlMeansDenoisingColored</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Photo.fastNlMeansDenoisingColoredMulti(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Mat,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)" -->
        <member name="M:OpenCVUnity.Photo.fastNlMeansDenoisingColoredMulti(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Mat,System.Int32,System.Int32)">
             <summary>Modification of <code>fastNlMeansDenoisingMulti</code> function for colored
             images sequences</summary>
            
             <p>The function converts images to CIELAB colorspace and then separately denoise
             L and AB components with given h parameters using <code>fastNlMeansDenoisingMulti</code>
             function.</p>
            
             <param>srcImgs Input 8-bit 3-channel images sequence. All images should have
             the same type and size.</param>
             <param>dst Output image with the same size and type as <code>srcImgs</code>
             images.</param>
             <param>imgToDenoiseIndex Target image to denoise index in <code>srcImgs</code>
             sequence</param>
             <param>temporalWindowSize Number of surrounding images to use for target
             image denoising. Should be odd. Images from <code>imgToDenoiseIndex -
             temporalWindowSize / 2</code> to <code>imgToDenoiseIndex - temporalWindowSize
             / 2</code> from <code>srcImgs</code> will be used to denoise
             <code>srcImgs[imgToDenoiseIndex]</code> image.</param>
            
             <a href="http://docs.opencv.org/modules/photo/doc/denoising.html#fastnlmeansdenoisingcoloredmulti">org.opencv.photo.Photo.fastNlMeansDenoisingColoredMulti</a>
        </member>
        <member name="M:OpenCVUnity.Photo.fastNlMeansDenoisingMulti(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Mat,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
             <summary>Modification of <code>fastNlMeansDenoising</code> function for images
             sequence where consequtive images have been captured in small period of time.
             For example video. This version of the function is for grayscale images or
             for manual manipulation with colorspaces.
             For more details see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394</summary>
            
             <param>srcImgs Input 8-bit 1-channel, 2-channel or 3-channel images sequence.
             All images should have the same type and size.</param>
             <param>dst Output image with the same size and type as <code>srcImgs</code>
             images.</param>
             <param>imgToDenoiseIndex Target image to denoise index in <code>srcImgs</code>
             sequence</param>
             <param>temporalWindowSize Number of surrounding images to use for target
             image denoising. Should be odd. Images from <code>imgToDenoiseIndex -
             temporalWindowSize / 2</code> to <code>imgToDenoiseIndex - temporalWindowSize
             / 2</code> from <code>srcImgs</code> will be used to denoise
             <code>srcImgs[imgToDenoiseIndex]</code> image.</param>
             <param>h Parameter regulating filter strength for luminance component. Bigger
             h value perfectly removes noise but also removes image details, smaller h
             value preserves details but also preserves some noise</param>
             <param>templateWindowSize Size in pixels of the template patch that is used
             to compute weights. Should be odd. Recommended value 7 pixels</param>
             <param>searchWindowSize Size in pixels of the window that is used to compute
             weighted average for given pixel. Should be odd. Affect performance linearly:
             greater searchWindowsSize - greater denoising time. Recommended value 21
             pixels</param>
            
             <a href="http://docs.opencv.org/modules/photo/doc/denoising.html#fastnlmeansdenoisingmulti">org.opencv.photo.Photo.fastNlMeansDenoisingMulti</a>
        </member>
        <member name="M:OpenCVUnity.Photo.fastNlMeansDenoisingMulti(System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Mat,System.Int32,System.Int32)">
             <summary>Modification of <code>fastNlMeansDenoising</code> function for images
             sequence where consequtive images have been captured in small period of time.
             For example video. This version of the function is for grayscale images or
             for manual manipulation with colorspaces.
             For more details see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394</summary>
            
             <param>srcImgs Input 8-bit 1-channel, 2-channel or 3-channel images sequence.
             All images should have the same type and size.</param>
             <param>dst Output image with the same size and type as <code>srcImgs</code>
             images.</param>
             <param>imgToDenoiseIndex Target image to denoise index in <code>srcImgs</code>
             sequence</param>
             <param>temporalWindowSize Number of surrounding images to use for target
             image denoising. Should be odd. Images from <code>imgToDenoiseIndex -
             temporalWindowSize / 2</code> to <code>imgToDenoiseIndex - temporalWindowSize
             / 2</code> from <code>srcImgs</code> will be used to denoise
             <code>srcImgs[imgToDenoiseIndex]</code> image.</param>
            
             <a href="http://docs.opencv.org/modules/photo/doc/denoising.html#fastnlmeansdenoisingmulti">org.opencv.photo.Photo.fastNlMeansDenoisingMulti</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Photo.inpaint(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Int32)" -->
        <member name="M:OpenCVUnity.Hash.URShift(System.Int32,System.Int32)">
            <summary>
            URs the shift.
            </summary>
            <returns>The shift.</returns>
            <param name="iNumber">Number.</param>
            <param name="iBits">Bits.</param>
        </member>
        <member name="M:OpenCVUnity.Hash.URShift(System.Int64,System.Int32)">
            <summary>
            URs the shift.
            </summary>
            <returns>The shift.</returns>
            <param name="iNumber">Number.</param>
            <param name="iBits">Bits.</param>
        </member>
        <member name="M:OpenCVUnity.Hash.HashContents``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if hash contents the specified enumerable.
            </summary>
            <returns><c>true</c> if hash contents the specified enumerable; otherwise, <c>false</c>.</returns>
            <param name="iEnumerable">Enumerable.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.BackgroundSubtractor" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.BackgroundSubtractorMOG2" -->
        <!-- Badly formed XML comment ignored for member "T:OpenCVUnity.KalmanFilter" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.CamShift(OpenCVUnity.Mat,OpenCVUnity.Rect,OpenCVUnity.TermCriteria)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.buildOpticalFlowPyramid(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Size,System.Int32,System.Boolean,System.Int32,System.Int32,System.Boolean)" -->
        <member name="M:OpenCVUnity.Video.buildOpticalFlowPyramid(OpenCVUnity.Mat,System.Collections.Generic.List{OpenCVUnity.Mat},OpenCVUnity.Size,System.Int32)">
             <summary>Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</summary>
            
             <param>img 8-bit input image.</param>
             <param>pyramid output pyramid.</param>
             <param>winSize window size of optical flow algorithm. Must be not less than
             <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to
             calculate required padding for pyramid levels.</param>
             <param>maxLevel 0-based maximal pyramid level number.</param>
            
             <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.calcOpticalFlowFarneback(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.calcOpticalFlowPyrLK(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfByte,OpenCVUnity.MatOfFloat,OpenCVUnity.Size,System.Int32,OpenCVUnity.TermCriteria,System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.calcOpticalFlowPyrLK(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfByte,OpenCVUnity.MatOfFloat,OpenCVUnity.Size,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.calcOpticalFlowPyrLK(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfPoint2f,OpenCVUnity.MatOfByte,OpenCVUnity.MatOfFloat)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.estimateRigidTransform(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.meanShift(OpenCVUnity.Mat,OpenCVUnity.Rect,OpenCVUnity.TermCriteria)" -->
        <member name="M:OpenCVUnity.Video.segmentMotion(OpenCVUnity.Mat,OpenCVUnity.Mat,OpenCVUnity.MatOfRect,System.Double,System.Double)">
             <summary>Splits a motion history image into a few parts corresponding to separate
             independent motions (for example, left hand, right hand).</summary>
            
             <p>The function finds all of the motion segments and marks them in
             <code>segmask</code> with individual values (1,2,...). It also computes a
             vector with ROIs of motion connected components. After that the motion
             direction for every component can be calculated with "calcGlobalOrientation"
             using the extracted mask of the particular component.</p>
            
             <param>mhi Motors history image.</param>
             <param>segmask Image where the found mask should be stored, single-channel,
             32-bit floating-point.</param>
             <param>boundingRects Vector containing ROIs of motion connected components.</param>
             <param>timestamp Current time in milliseconds or other units.</param>
             <param>segThresh Segmentation threshold that is recommended to be equal to
             the interval between motion history "steps" or greater.</param>
            
             <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#segmentmotion">org.opencv.video.Video.segmentMotion</a>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenCVUnity.Video.updateMotionHistory(OpenCVUnity.Mat,OpenCVUnity.Mat,System.Double,System.Double)" -->
    </members>
</doc>
